<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YADORI</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      cursor: none;
      font-family: monospace;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.15);
      font-size: 11px;
      line-height: 1.6;
      pointer-events: none;
      transition: color 0.5s;
      white-space: pre;
    }
    body:hover #info { color: rgba(255, 255, 255, 0.4); }
    #milestones {
      position: fixed;
      top: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0);
      font-size: 12px;
      line-height: 1.8;
      text-align: right;
      pointer-events: none;
      transition: color 3s;
    }
    #milestones.show { color: rgba(255, 255, 255, 0.35); }
    #sulk-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      transition: background 2s;
    }
    #encounter-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    #encounter-expression {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0);
      font-size: 28px;
      letter-spacing: 8px;
      text-align: center;
      pointer-events: none;
      z-index: 11;
      transition: color 2s, letter-spacing 3s, font-size 2s;
      white-space: nowrap;
    }
    #encounter-expression.reveal {
      color: rgba(255, 255, 255, 0.9);
      letter-spacing: 16px;
      font-size: 36px;
    }
    #encounter-expression.fade {
      color: rgba(255, 255, 255, 0);
      letter-spacing: 24px;
    }
    #dormant-text {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0);
      font-size: 12px;
      pointer-events: none;
      z-index: 5;
      transition: color 3s;
    }
    #dormant-text.show {
      color: rgba(255, 255, 255, 0.15);
    }

    /* Milestone celebration */
    #milestone-celebration {
      position: fixed;
      top: 38%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      z-index: 15;
      opacity: 0;
    }
    #milestone-celebration .milestone-label {
      font-size: 13px;
      letter-spacing: 3px;
      color: rgba(255, 255, 255, 0);
      transition: color 1.5s, letter-spacing 2s;
      white-space: nowrap;
    }
    #milestone-celebration.reveal .milestone-label {
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 5px;
    }
    #milestone-celebration.fade .milestone-label {
      color: rgba(255, 255, 255, 0);
      letter-spacing: 8px;
    }

    /* Coexistence Log */
    #coexistence-log {
      position: fixed;
      top: 0; right: 0;
      width: 280px;
      height: 100vh;
      padding: 40px 28px;
      background: rgba(0, 0, 0, 0.85);
      border-left: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateX(100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
      overflow-y: auto;
    }
    #coexistence-log.open { transform: translateX(0); }

    #coexistence-log h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 32px;
    }

    .log-field {
      margin-bottom: 20px;
    }
    .log-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .log-value {
      font-size: 20px;
      color: rgba(255, 255, 255, 0.6);
      font-family: 'Courier New', monospace;
    }
    .log-unit {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.2);
      margin-left: 4px;
    }
    .log-divider {
      width: 40px;
      height: 1px;
      background: rgba(255, 255, 255, 0.06);
      margin: 24px 0;
    }
    .log-silence {
      font-size: 14px;
    }

    #log-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #log-toggle { opacity: 0.3; }
    #log-toggle:hover { opacity: 0.6 !important; }
    #log-toggle svg { width: 24px; height: 24px; }

    /* Sound toggle */
    #sound-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 28px;
      height: 28px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    body:hover #sound-toggle { opacity: 0.3; }
    #sound-toggle:hover { opacity: 0.6 !important; }
    #sound-toggle svg { width: 22px; height: 22px; }
    #sound-toggle.muted svg .sound-wave { opacity: 0; }
    #sound-toggle.muted::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 20px;
      background: rgba(255, 255, 255, 0.6);
      transform: rotate(45deg);
      top: 4px;
      left: 13px;
    }

    /* Sound growth level indicator */
    #sound-growth {
      position: fixed;
      bottom: 50px;
      right: 20px;
      display: flex;
      gap: 3px;
      align-items: center;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
      cursor: default;
    }
    body:hover #sound-growth { opacity: 0.3; }
    #sound-growth:hover { opacity: 0.6 !important; }
    .sound-growth-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.12);
      transition: background 0.5s;
    }
    .sound-growth-dot.filled {
      background: rgba(255, 255, 255, 0.5);
    }

    /* Senses Panel (left side) */
    #senses-panel {
      position: fixed;
      top: 0; left: 0;
      width: 280px;
      height: 100vh;
      padding: 40px 28px;
      background: rgba(0, 0, 0, 0.85);
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateX(-100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
      overflow-y: auto;
    }
    #senses-panel.open { transform: translateX(0); }

    #senses-panel h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 32px;
    }

    .sense-item {
      margin-bottom: 14px;
      padding: 6px 0;
    }
    .sense-description {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.45);
      font-family: 'Courier New', monospace;
      line-height: 1.4;
    }
    .sense-empty {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.15);
      font-style: italic;
      line-height: 1.6;
    }
    .sense-level {
      display: flex;
      gap: 3px;
      margin-top: 4px;
    }
    .sense-level-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.08);
    }
    .sense-level-dot.active {
      background: rgba(255, 255, 255, 0.4);
    }

    #senses-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #senses-toggle { opacity: 0.3; }
    #senses-toggle:hover { opacity: 0.6 !important; }
    #senses-toggle svg { width: 24px; height: 24px; }

    /* Diary Panel (bottom slide-up, two-column layout) */
    #diary-panel {
      position: fixed;
      bottom: 0; left: 0;
      width: 600px;
      max-height: 60vh;
      display: flex;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.90);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateY(100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
    }
    #diary-panel.open { transform: translateY(0); }
    #diary-panel h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin: 0;
      padding: 20px 24px 14px 24px;
      flex-shrink: 0;
    }
    .diary-columns {
      display: flex;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    .diary-date-list {
      width: 140px;
      flex-shrink: 0;
      overflow-y: auto;
      border-right: 1px solid rgba(255, 255, 255, 0.06);
      padding: 4px 0 12px 0;
    }
    .diary-date-item {
      display: block;
      width: 100%;
      padding: 6px 16px;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      color: rgba(255, 255, 255, 0.3);
      background: none;
      border: none;
      text-align: left;
      cursor: pointer;
      transition: color 0.2s, background 0.2s;
      letter-spacing: 0.5px;
    }
    .diary-date-item:hover {
      color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.04);
    }
    .diary-date-item.active {
      color: rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.06);
    }
    .diary-content-area {
      flex: 1;
      overflow-y: auto;
      padding: 8px 24px 20px 20px;
      min-width: 0;
    }
    .diary-content-date {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.25);
      font-family: 'Courier New', monospace;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }
    .diary-body {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.55);
      font-family: 'Courier New', monospace;
      line-height: 1.8;
      word-break: break-word;
    }
    .diary-body h1 {
      font-size: 15px;
      font-weight: normal;
      color: rgba(255, 255, 255, 0.6);
      letter-spacing: 2px;
      margin: 16px 0 8px 0;
    }
    .diary-body h2 {
      font-size: 13px;
      font-weight: normal;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 2px;
      margin: 12px 0 6px 0;
      padding: 0;
      text-transform: none;
    }
    .diary-body h3 {
      font-size: 12px;
      font-weight: normal;
      color: rgba(255, 255, 255, 0.45);
      letter-spacing: 1px;
      margin: 10px 0 4px 0;
    }
    .diary-body strong { color: rgba(255, 255, 255, 0.7); }
    .diary-body em { color: rgba(255, 255, 255, 0.5); font-style: italic; }
    .diary-body ul, .diary-body ol {
      margin: 4px 0 4px 16px;
      padding: 0;
    }
    .diary-body li {
      margin-bottom: 2px;
    }
    .diary-body p {
      margin: 6px 0;
    }
    .diary-empty {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.15);
      font-style: italic;
    }

    #diary-toggle {
      position: fixed;
      bottom: 20px;
      left: 60px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #diary-toggle { opacity: 0.3; }
    #diary-toggle:hover { opacity: 0.6 !important; }
    #diary-toggle svg { width: 24px; height: 24px; }

    /* Error Log Panel (bottom-right slide-up) */
    #errorlog-panel {
      position: fixed;
      bottom: 0; right: 0;
      width: 380px;
      max-height: 50vh;
      padding: 28px 24px;
      background: rgba(0, 0, 0, 0.88);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      border-left: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateY(100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
      overflow-y: auto;
    }
    #errorlog-panel.open { transform: translateY(0); }
    #errorlog-panel h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 20px;
    }
    .log-entry {
      margin-bottom: 8px;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      line-height: 1.5;
    }
    .log-entry-time {
      color: rgba(255, 255, 255, 0.2);
    }
    .log-entry-level {
      font-weight: bold;
      margin: 0 4px;
    }
    .log-entry-level.ERROR { color: rgba(255, 80, 80, 0.7); }
    .log-entry-level.WARN  { color: rgba(255, 200, 80, 0.7); }
    .log-entry-level.INFO  { color: rgba(100, 200, 255, 0.4); }
    .log-entry-msg {
      color: rgba(255, 255, 255, 0.4);
    }
    .errorlog-empty {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.15);
      font-style: italic;
    }

    #errorlog-toggle {
      position: fixed;
      bottom: 20px;
      right: 60px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #errorlog-toggle { opacity: 0.3; }
    #errorlog-toggle:hover { opacity: 0.6 !important; }
    #errorlog-toggle svg { width: 24px; height: 24px; }

    /* Milestone Timeline Panel (bottom-right slide-up) */
    #milestone-panel {
      position: fixed;
      bottom: 0; right: 0;
      width: 320px;
      max-height: 65vh;
      padding: 28px 24px;
      background: rgba(0, 0, 0, 0.88);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      border-left: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateY(100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
      overflow-y: auto;
    }
    #milestone-panel.open { transform: translateY(0); }
    #milestone-panel h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 12px;
    }
    .milestone-stage {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.45);
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 20px;
    }
    .milestone-timeline {
      position: relative;
      padding-left: 20px;
    }
    .milestone-timeline::before {
      content: '';
      position: absolute;
      left: 5px;
      top: 4px;
      bottom: 4px;
      width: 1px;
      background: rgba(255, 255, 255, 0.1);
    }
    .milestone-item {
      position: relative;
      margin-bottom: 16px;
      padding-bottom: 2px;
    }
    .milestone-item::before {
      content: '';
      position: absolute;
      left: -19px;
      top: 5px;
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    .milestone-day {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.2);
      font-family: 'Courier New', monospace;
      letter-spacing: 1px;
      margin-bottom: 2px;
    }
    .milestone-name {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      font-family: 'Courier New', monospace;
      line-height: 1.4;
    }
    .milestone-empty {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.15);
      font-style: italic;
    }

    #milestone-toggle {
      position: fixed;
      bottom: 20px;
      right: 100px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #milestone-toggle { opacity: 0.3; }
    #milestone-toggle:hover { opacity: 0.6 !important; }
    #milestone-toggle svg { width: 24px; height: 24px; }

    /* Dynamics Panel (bottom-left) */
    #dynamics-panel {
      position: fixed;
      bottom: 60px;
      left: 20px;
      pointer-events: none;
      z-index: 5;
      transition: opacity 0.5s;
      opacity: 0;
    }
    body:hover #dynamics-panel { opacity: 1; }
    .dynamics-phase {
      font-size: 22px;
      color: rgba(255, 255, 255, 0.5);
      font-family: 'Courier New', monospace;
      letter-spacing: 2px;
    }
    .dynamics-phase-symbol {
      font-size: 28px;
      color: rgba(255, 255, 255, 0.6);
      margin-right: 6px;
    }
    .dynamics-phase-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .dynamics-score-bar {
      width: 80px;
      height: 3px;
      background: rgba(255, 255, 255, 0.08);
      margin-top: 6px;
      border-radius: 1.5px;
      overflow: hidden;
    }
    .dynamics-score-fill {
      height: 100%;
      background: rgba(255, 255, 255, 0.35);
      border-radius: 1.5px;
      transition: width 1s ease;
    }
    .dynamics-signals {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.15);
      margin-top: 4px;
      max-width: 160px;
      line-height: 1.4;
    }

    /* Day Counter (top-center) */
    #day-counter {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 5;
      opacity: 0;
      transition: opacity 0.5s;
    }
    body:hover #day-counter { opacity: 1; }
    .day-count {
      font-size: 28px;
      color: rgba(255, 255, 255, 0.5);
      font-family: 'Courier New', monospace;
      letter-spacing: 3px;
      font-weight: normal;
    }
    .day-birth {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.15);
      letter-spacing: 2px;
      margin-top: 2px;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      body { cursor: default; }

      #info {
        font-size: 10px;
        bottom: 10px;
        left: 10px;
        color: rgba(255, 255, 255, 0.3);
      }
      body:hover #info { color: rgba(255, 255, 255, 0.4); }

      #milestones {
        font-size: 10px;
        top: 10px;
        right: 10px;
      }

      #day-counter {
        top: 10px;
        opacity: 0.8;
      }
      .day-count { font-size: 20px; letter-spacing: 2px; }
      .day-birth { font-size: 9px; }

      #dynamics-panel {
        bottom: 50px;
        left: 10px;
        opacity: 0.7;
      }
      .dynamics-phase-symbol { font-size: 22px; }
      .dynamics-score-bar { width: 60px; }

      /* Panels fill screen on mobile */
      #coexistence-log,
      #senses-panel {
        width: 100vw;
        padding: 24px 20px;
      }

      #diary-panel {
        width: 100vw;
        max-height: 70vh;
      }
      .diary-date-list {
        width: 110px;
      }
      .diary-content-area {
        padding: 8px 16px 16px 12px;
      }
      .diary-body { font-size: 12px; }

      #errorlog-panel,
      #milestone-panel {
        width: 100vw;
        max-height: 70vh;
        padding: 20px 16px;
      }

      /* Toggle buttons always visible on mobile */
      #log-toggle, #senses-toggle, #diary-toggle, #errorlog-toggle, #milestone-toggle, #sound-toggle, #sound-growth {
        opacity: 0.35 !important;
      }

      #log-toggle { top: 10px; right: 10px; }
      #senses-toggle { top: 10px; left: 10px; }
      #diary-toggle { bottom: 10px; left: 50px; }
      #errorlog-toggle { bottom: 10px; right: 50px; }
      #milestone-toggle { bottom: 10px; right: 90px; }
      #sound-toggle { bottom: 10px; right: 10px; }
      #sound-growth { bottom: 40px; right: 10px; }

      #encounter-expression {
        font-size: 22px;
        letter-spacing: 4px;
      }
      #encounter-expression.reveal {
        font-size: 28px;
        letter-spacing: 10px;
      }

      #dormant-text {
        bottom: 40px;
        font-size: 11px;
      }
    }

    @media (max-width: 480px) {
      .day-count { font-size: 16px; }
      .dynamics-phase-symbol { font-size: 18px; }
      .dynamics-score-bar { width: 50px; }

      #coexistence-log,
      #senses-panel {
        padding: 20px 16px;
      }

      .log-value { font-size: 16px; }
      .diary-date-list { width: 90px; }
      .diary-date-item { font-size: 10px; padding: 5px 10px; }
      .diary-body { font-size: 11px; }
    }
  </style>
</head>
<body>
  <div id="sulk-overlay"></div>
  <div id="encounter-overlay"></div>
  <div id="encounter-expression"></div>
  <div id="dormant-text"></div>
  <div id="milestone-celebration"><div class="milestone-label"></div></div>
  <canvas id="canvas"></canvas>
  <div id="day-counter">
    <div class="day-count" id="day-count-value">Day 0</div>
    <div class="day-birth" id="day-birth-date"></div>
  </div>
  <div id="dynamics-panel">
    <div>
      <span class="dynamics-phase-symbol" id="dynamics-symbol">&alpha;</span>
      <span class="dynamics-phase-label" id="dynamics-label">Dependency</span>
    </div>
    <div class="dynamics-score-bar">
      <div class="dynamics-score-fill" id="dynamics-score-fill" style="width: 0%"></div>
    </div>
    <div class="dynamics-signals" id="dynamics-signals"></div>
  </div>
  <div id="info"></div>
  <div id="milestones"></div>

  <div id="log-toggle" title="Coexistence Log">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <rect x="3" y="3" width="18" height="18" rx="2"/>
      <line x1="8" y1="8" x2="16" y2="8"/>
      <line x1="8" y1="12" x2="16" y2="12"/>
      <line x1="8" y1="16" x2="12" y2="16"/>
    </svg>
  </div>
  <div id="senses-toggle" title="Senses">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <circle cx="12" cy="12" r="3"/>
      <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7S2 12 2 12z"/>
    </svg>
  </div>
  <div id="senses-panel">
    <h2>Senses</h2>
    <div id="senses-content"><span class="sense-empty">· · ·</span></div>
  </div>
  <div id="diary-toggle" title="Diary">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <path d="M4 19.5A2.5 2.5 0 016.5 17H20"/>
      <path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/>
      <line x1="8" y1="7" x2="16" y2="7"/>
      <line x1="8" y1="11" x2="13" y2="11"/>
    </svg>
  </div>
  <div id="diary-panel">
    <h2>Diary</h2>
    <div class="diary-columns">
      <div class="diary-date-list" id="diary-date-list"></div>
      <div class="diary-content-area" id="diary-content-area">
        <span class="diary-empty">No entries yet.</span>
      </div>
    </div>
  </div>

  <div id="errorlog-toggle" title="System Log">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <path d="M12 9v4"/>
      <circle cx="12" cy="16" r="0.5" fill="rgba(255,255,255,0.6)"/>
      <path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/>
    </svg>
  </div>
  <div id="errorlog-panel">
    <h2>System Log</h2>
    <div id="errorlog-content"><span class="errorlog-empty">No log entries.</span></div>
  </div>

  <div id="milestone-toggle" title="Milestones">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/>
    </svg>
  </div>
  <div id="milestone-panel">
    <h2>Milestones</h2>
    <div id="milestone-content"><span class="milestone-empty">No milestones yet.</span></div>
  </div>

  <div id="sound-growth" title="Sound growth: Level 1 — Single tone">
    <span class="sound-growth-dot"></span>
    <span class="sound-growth-dot"></span>
    <span class="sound-growth-dot"></span>
    <span class="sound-growth-dot"></span>
    <span class="sound-growth-dot"></span>
  </div>
  <div id="sound-toggle" class="muted" title="Toggle sound">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <path d="M11 5L6 9H2v6h4l5 4V5z"/>
      <path class="sound-wave" d="M15.54 8.46a5 5 0 010 7.07"/>
      <path class="sound-wave" d="M19.07 4.93a10 10 0 010 14.14"/>
    </svg>
  </div>
  <div id="coexistence-log">
    <h2>Coexistence Log</h2>
    <div id="log-content">· · ·</div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoEl = document.getElementById('info');
    const milestonesEl = document.getElementById('milestones');
    const sulkOverlay = document.getElementById('sulk-overlay');
    const encounterOverlay = document.getElementById('encounter-overlay');
    const encounterExpr = document.getElementById('encounter-expression');
    const dormantText = document.getElementById('dormant-text');

    // --- Full entity state ---
    const entity = {
      status: { mood: 50, energy: 50, curiosity: 70, comfort: 50, growthDay: 0, languageLevel: 0 },
      seed: { perception: 'chromatic', form: 'light-particles', temperament: 'curious-cautious' },
      form: { baseForm: 'light-particles', density: 5, complexity: 3, stability: 15, awareness: false },
      sulk: { isSulking: false, severity: 'none' },
      growth: { stage: 'newborn', milestones: [] },
      language: { totalInteractions: 0 },
    };

    // --- First Encounter state ---
    let prevInteractions = -1; // -1 = unknown yet
    let encounterPhase = 'none'; // 'none' | 'dormant' | 'awakening' | 'afterglow' | 'done'
    let awakeningStartTime = 0;
    const AWAKENING_DURATION = 8000; // 8 seconds of awakening animation
    const AFTERGLOW_DURATION = 10000; // 10 seconds of afterglow

    // --- Milestone celebration state ---
    const knownMilestoneIds = new Set();
    let celebrationActive = false;
    let celebrationStartTime = 0;
    const CELEBRATION_DURATION = 5000; // 5 seconds total
    // Ripple rings spawned during celebration
    let celebrationRipples = [];
    const milestoneCelebEl = document.getElementById('milestone-celebration');
    const milestoneLabelEl = milestoneCelebEl.querySelector('.milestone-label');

    // --- Perception-based color palettes ---
    const PALETTES = {
      chromatic:  { hueBase: 20,  hueRange: 30, satBase: 60, satRange: 40 },
      vibration:  { hueBase: 250, hueRange: 40, satBase: 50, satRange: 30 },
      geometric:  { hueBase: 180, hueRange: 20, satBase: 30, satRange: 40 },
      thermal:    { hueBase: 0,   hueRange: 40, satBase: 70, satRange: 30 },
      temporal:   { hueBase: 210, hueRange: 50, satBase: 40, satRange: 30 },
      chemical:   { hueBase: 90,  hueRange: 40, satBase: 50, satRange: 40 },
    };

    // --- Form-based rendering parameters ---
    const FORM_PARAMS = {
      'light-particles': { shape: 'circle', trailAlpha: 0.12 },
      'fluid':           { shape: 'circle', trailAlpha: 0.06 },
      'crystal':         { shape: 'diamond', trailAlpha: 0.18 },
      'sound-echo':      { shape: 'ring',   trailAlpha: 0.08 },
      'mist':            { shape: 'circle', trailAlpha: 0.04 },
      'geometric-cluster': { shape: 'square', trailAlpha: 0.15 },
    };

    // Poll entity state every 3 seconds
    async function fetchState() {
      try {
        const res = await fetch('/api/entity');
        if (!res.ok) return;
        const data = await res.json();

        if (data.status) {
          entity.status = { ...entity.status, ...data.status };
        }
        if (data.seed) {
          entity.seed = { ...entity.seed, ...data.seed };
        }
        if (data.form) {
          entity.form = { ...entity.form, ...data.form };
        }
        if (data.sulk) {
          entity.sulk = { ...entity.sulk, ...data.sulk };
        }
        if (data.growth) {
          entity.growth = { ...entity.growth, ...data.growth };
        }
        if (data.language) {
          entity.language = { ...entity.language, ...data.language };
        }

        // --- Detect first encounter transition ---
        const currentInteractions = entity.language.totalInteractions ?? 0;
        if (prevInteractions === -1) {
          // First poll: set state
          prevInteractions = currentInteractions;
          if (currentInteractions === 0) {
            encounterPhase = 'dormant';
            dormantText.textContent = '· · · waiting · · ·';
            dormantText.classList.add('show');
          } else {
            encounterPhase = 'done';
          }
        } else if (prevInteractions === 0 && currentInteractions >= 1) {
          // The transition happened!
          triggerAwakening(data);
        }
        prevInteractions = currentInteractions;

        updateInfo();
        updateSulkOverlay();
        updateMilestones();
        updateDormantState();
        detectNewMilestones();
      } catch { /* server not available */ }
    }
    fetchState();
    setInterval(fetchState, 3000);

    // --- Dynamics Panel ---
    const PHASE_MAP = {
      alpha: { symbol: '\u03B1', label: 'Dependency' },
      beta:  { symbol: '\u03B2', label: 'Learning' },
      gamma: { symbol: '\u03B3', label: 'Parity' },
      delta: { symbol: '\u03B4', label: 'Transcendence' },
      epsilon: { symbol: '\u03B5', label: 'Coexistence' },
    };

    const dynamicsSymbolEl = document.getElementById('dynamics-symbol');
    const dynamicsLabelEl = document.getElementById('dynamics-label');
    const dynamicsScoreFillEl = document.getElementById('dynamics-score-fill');
    const dynamicsSignalsEl = document.getElementById('dynamics-signals');

    async function fetchDynamics() {
      try {
        const res = await fetch('/api/dynamics');
        if (!res.ok) return;
        const d = await res.json();
        const phaseInfo = PHASE_MAP[d.phase] || PHASE_MAP.alpha;
        dynamicsSymbolEl.textContent = phaseInfo.symbol;
        dynamicsLabelEl.textContent = phaseInfo.label;
        dynamicsScoreFillEl.style.width = Math.min(100, Math.max(0, d.score)) + '%';
        if (d.signals && d.signals.length > 0) {
          dynamicsSignalsEl.textContent = d.signals.slice(0, 2).join(' · ');
        } else {
          dynamicsSignalsEl.textContent = '';
        }
      } catch { /* not available */ }
    }
    fetchDynamics();
    setInterval(fetchDynamics, 30000);

    // --- Day Counter / Anniversary ---
    const dayCountValueEl = document.getElementById('day-count-value');
    const dayBirthDateEl = document.getElementById('day-birth-date');

    function updateDayCounter() {
      const day = entity.status.growthDay ?? 0;
      dayCountValueEl.textContent = 'Day ' + day;
    }
    updateDayCounter();

    // Fetch seed data once for birth date
    async function fetchSeedForBirthDate() {
      try {
        const res = await fetch('/api/seed');
        if (!res.ok) return;
        const d = await res.json();
        if (d.born) {
          const date = new Date(d.born);
          if (!isNaN(date.getTime())) {
            const formatted = date.toLocaleDateString('en-US', {
              year: 'numeric', month: 'short', day: 'numeric'
            });
            dayBirthDateEl.textContent = 'born ' + formatted;
          }
        }
      } catch { /* not available */ }
    }
    fetchSeedForBirthDate();

    // Hook into fetchState to update day counter on each poll
    const _origFetchStateForDay = fetchState;
    fetchState = async function() {
      await _origFetchStateForDay();
      updateDayCounter();
    };

    function detectNewMilestones() {
      if (!entity.growth.milestones || entity.growth.milestones.length === 0) return;
      const currentIds = entity.growth.milestones.map(m => m.id);

      // First poll: seed known set without triggering celebration
      if (knownMilestoneIds.size === 0) {
        currentIds.forEach(id => knownMilestoneIds.add(id));
        return;
      }

      // Check for newly achieved milestones
      const newOnes = [];
      for (const m of entity.growth.milestones) {
        if (!knownMilestoneIds.has(m.id)) {
          knownMilestoneIds.add(m.id);
          newOnes.push(m);
        }
      }

      if (newOnes.length > 0 && !celebrationActive) {
        triggerMilestoneCelebration(newOnes[newOnes.length - 1]);
      }
    }

    function triggerMilestoneCelebration(milestone) {
      celebrationActive = true;
      celebrationStartTime = performance.now();
      celebrationRipples = [];

      // Show milestone label
      const shortLabel = milestone.label.split(' — ')[0];
      milestoneLabelEl.textContent = shortLabel;
      milestoneCelebEl.style.opacity = '1';

      // Spawn ripple rings staggered over 2 seconds
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          celebrationRipples.push({
            startTime: performance.now(),
            duration: 2500 + i * 300,
          });
        }, i * 600);
      }

      // Phase 1: reveal text
      setTimeout(() => {
        milestoneCelebEl.classList.add('reveal');
      }, 300);

      // Phase 2: begin fading
      setTimeout(() => {
        milestoneCelebEl.classList.remove('reveal');
        milestoneCelebEl.classList.add('fade');
      }, CELEBRATION_DURATION - 1500);

      // Phase 3: cleanup
      setTimeout(() => {
        milestoneCelebEl.classList.remove('fade');
        milestoneCelebEl.style.opacity = '0';
        milestoneLabelEl.textContent = '';
        celebrationActive = false;
        celebrationRipples = [];
      }, CELEBRATION_DURATION);

      // Trigger celebration sound
      SoundEngine.onMilestone();
    }

    function triggerAwakening(data) {
      encounterPhase = 'awakening';
      awakeningStartTime = performance.now();

      // Hide dormant text
      dormantText.classList.remove('show');

      // Flash the encounter overlay
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const hue = pal.hueBase + pal.hueRange / 2;
      encounterOverlay.style.background = `radial-gradient(circle at 50% 50%, hsla(${hue}, 80%, 60%, 0.4), transparent 70%)`;
      encounterOverlay.style.opacity = '1';

      // Generate the first encounter expression for display
      const expressions = generateEncounterExpression(entity.seed.perception, entity.seed.temperament);
      encounterExpr.textContent = expressions;

      // Phase 1: Reveal expression (after 1.5s flash)
      setTimeout(() => {
        encounterExpr.classList.add('reveal');
      }, 1500);

      // Phase 2: Fade overlay
      setTimeout(() => {
        encounterOverlay.style.opacity = '0';
      }, 3000);

      // Phase 3: Expression begins fading
      setTimeout(() => {
        encounterExpr.classList.remove('reveal');
        encounterExpr.classList.add('fade');
        encounterPhase = 'afterglow';
      }, AWAKENING_DURATION);

      // Phase 4: Complete
      setTimeout(() => {
        encounterExpr.classList.remove('fade');
        encounterExpr.textContent = '';
        encounterPhase = 'done';
      }, AWAKENING_DURATION + AFTERGLOW_DURATION);
    }

    // Generate a visual expression matching the engine's first encounter output
    function generateEncounterExpression(perception, temperament) {
      const speciesSymbols = {
        chromatic:  { core: ['◎', '○', '☆'], other: '☆' },
        vibration:  { core: ['◈', '◇', '△'], other: '△' },
        geometric:  { core: ['□', '△', '◇'], other: '◇' },
        thermal:    { core: ['○', '◎'],       other: '◎' },
        temporal:   { core: ['○', '◉'],       other: '◉' },
        chemical:   { core: ['◆', '◈', '★'], other: '★' },
      };
      const sp = speciesSymbols[perception] || speciesSymbols.chromatic;

      switch (temperament) {
        case 'curious-cautious':
          return sp.core.join('  ') + '   ' + sp.other;
        case 'bold-impulsive':
          return sp.core.join('') + ' ' + sp.other + ' ' + sp.core.join('');
        case 'calm-observant':
          return '      ' + sp.core[0] + '      ' + sp.other;
        case 'restless-exploratory':
          return sp.core.map(s => s + sp.other).join(' ');
        default:
          return sp.core.join(' ') + ' ' + sp.other;
      }
    }

    function updateDormantState() {
      if (encounterPhase !== 'dormant') return;
      dormantText.textContent = '· · · waiting · · ·';
      dormantText.classList.add('show');
    }

    function updateInfo() {
      const s = entity.status;
      const g = entity.growth;
      infoEl.textContent = `day ${s.growthDay} · ${g.stage} · ${entity.seed.perception}`;
    }

    function updateSulkOverlay() {
      if (entity.sulk.isSulking) {
        const opacity = entity.sulk.severity === 'severe' ? 0.4 :
                        entity.sulk.severity === 'moderate' ? 0.2 : 0.1;
        sulkOverlay.style.background = `rgba(0, 0, 30, ${opacity})`;
      } else {
        sulkOverlay.style.background = 'transparent';
      }
    }

    function updateMilestones() {
      if (!entity.growth.milestones || entity.growth.milestones.length === 0) return;
      const latest = entity.growth.milestones.slice(-3);
      milestonesEl.innerHTML = latest.map(m =>
        `Day ${m.achievedDay}: ${m.label.split(' — ')[0]}`
      ).join('<br>');
      milestonesEl.classList.add('show');
    }

    // --- Resize ---
    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Particle ---
    const particle = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      phase: Math.random() * Math.PI * 2,
      driftPhaseX: Math.random() * Math.PI * 2,
      driftPhaseY: Math.random() * Math.PI * 2,
    };

    // --- Color from perception + mood ---
    function getColor(mood, alpha) {
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const hue = pal.hueBase + (mood / 100) * pal.hueRange;
      const sat = pal.satBase + (mood / 100) * pal.satRange;
      const light = 40 + (mood / 100) * 30;
      return `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
    }

    // --- Draw entity based on form ---
    function drawEntity(x, y, baseRadius, breathAlpha) {
      const form = FORM_PARAMS[entity.form.baseForm] || FORM_PARAMS['light-particles'];
      const mood = entity.status.mood;
      const density = entity.form.density;
      const complexity = entity.form.complexity;

      // Radius scales with density
      const densityScale = 0.5 + (density / 100) * 1.5;
      const radius = baseRadius * densityScale;

      // Number of glow layers scales with complexity
      const layerCount = 3 + Math.floor((complexity / 100) * 5);

      for (let i = layerCount - 1; i >= 0; i--) {
        const t = i / layerCount;
        const layerScale = 1 + t * (8 + complexity / 15);
        const layerAlpha = (1 - t * 0.85) * breathAlpha * 0.6;
        const r = radius * layerScale;

        if (form.shape === 'diamond') {
          drawDiamond(x, y, r, getColor(mood, layerAlpha));
        } else if (form.shape === 'ring') {
          drawRing(x, y, r, getColor(mood, layerAlpha), layerAlpha);
        } else if (form.shape === 'square') {
          drawSquare(x, y, r, getColor(mood, layerAlpha));
        } else {
          drawCircleGlow(x, y, r, mood, layerAlpha);
        }
      }

      // Sulking: dark core
      if (entity.sulk.isSulking) {
        const sulkAlpha = entity.sulk.severity === 'severe' ? 0.6 :
                          entity.sulk.severity === 'moderate' ? 0.3 : 0.15;
        ctx.fillStyle = `rgba(0, 0, 20, ${sulkAlpha})`;
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCircleGlow(x, y, r, mood, alpha) {
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      gradient.addColorStop(0, getColor(mood, alpha));
      gradient.addColorStop(1, getColor(mood, 0));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawDiamond(x, y, r, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y - r);
      ctx.lineTo(x + r * 0.6, y);
      ctx.lineTo(x, y + r);
      ctx.lineTo(x - r * 0.6, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawRing(x, y, r, color, alpha) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 1 + alpha * 3;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawSquare(x, y, r, color) {
      ctx.fillStyle = color;
      const half = r * 0.7;
      ctx.fillRect(x - half, y - half, half * 2, half * 2);
    }

    // --- Animation ---
    let time = 0;

    function animate() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const form = FORM_PARAMS[entity.form.baseForm] || FORM_PARAMS['light-particles'];
      const now = performance.now();

      // Clear with trail (form-specific trail length)
      ctx.fillStyle = `rgba(0, 0, 0, ${form.trailAlpha})`;
      ctx.fillRect(0, 0, w, h);

      time += 0.016;

      const s = entity.status;

      // --- Dormant state: entity exists but hasn't met anyone ---
      if (encounterPhase === 'dormant') {
        // Very slow, dim breathing — alone in the void
        particle.phase += 0.15 * 0.016 * Math.PI * 2;
        const dormantBreath = 0.2 + 0.15 * Math.sin(particle.phase);
        const x = w / 2;
        const y = h / 2;
        drawEntity(x, y, 2, dormantBreath);
        requestAnimationFrame(animate);
        return;
      }

      // --- Awakening animation ---
      if (encounterPhase === 'awakening') {
        const elapsed = now - awakeningStartTime;
        const progress = Math.min(elapsed / AWAKENING_DURATION, 1);

        // Rapid expansion then settle
        const expansionCurve = progress < 0.3
          ? easeOutExpo(progress / 0.3)     // Rapid expansion
          : 1.0 - 0.3 * (1 - easeOutExpo((progress - 0.3) / 0.7)); // Settle

        const awakeBreath = 0.3 + 0.7 * expansionCurve;
        const awakeRadius = 2 + 6 * expansionCurve;

        // Slight tremor during awakening
        const tremor = (1 - progress) * 3;
        const tx = (Math.random() - 0.5) * tremor;
        const ty = (Math.random() - 0.5) * tremor;

        drawEntity(w / 2 + tx, h / 2 + ty, awakeRadius, awakeBreath);

        // Draw encounter sparkles radiating outward
        if (progress < 0.6) {
          drawEncounterSparkles(w / 2, h / 2, elapsed, progress);
        }

        requestAnimationFrame(animate);
        return;
      }

      // --- Afterglow: slightly enhanced normal ---
      let glowBoost = 0;
      if (encounterPhase === 'afterglow') {
        const elapsed = now - (awakeningStartTime + AWAKENING_DURATION);
        const fadeProgress = Math.min(elapsed / AFTERGLOW_DURATION, 1);
        glowBoost = (1 - fadeProgress) * 0.3; // Extra brightness fading out
      }

      // --- Normal animation ---
      // Breathing speed from energy
      const breathSpeed = 0.3 + (s.energy / 100) * 0.7;

      // Stability from form engine (inverse wobble)
      const stabilityFactor = entity.form.stability / 100;
      const wobble = 1.0 - stabilityFactor * 0.7;

      // Breathing pulse
      particle.phase += breathSpeed * 0.016 * Math.PI * 2;

      // Sulking slows everything
      let breathMod = 1;
      if (entity.sulk.isSulking) {
        breathMod = entity.sulk.severity === 'severe' ? 0.2 :
                    entity.sulk.severity === 'moderate' ? 0.5 : 0.7;
      }
      const breath = (0.6 + 0.4 * Math.sin(particle.phase) * breathMod) + glowBoost;

      // Drift from curiosity
      const driftRange = 5 + (s.curiosity / 100) * 25;
      particle.driftPhaseX += 0.003 * wobble;
      particle.driftPhaseY += 0.004 * wobble;
      const driftX = Math.sin(particle.driftPhaseX) * driftRange;
      const driftY = Math.cos(particle.driftPhaseY) * driftRange * 0.7;

      const x = w / 2 + driftX;
      const y = h / 2 + driftY;

      // Celebration pulse: entity briefly swells
      let celebRadius = 3;
      let celebBreath = Math.min(breath, 1);
      if (celebrationActive) {
        const celebElapsed = now - celebrationStartTime;
        const celebProgress = Math.min(celebElapsed / CELEBRATION_DURATION, 1);
        // Quick swell then settle: peaks at 0.15 progress
        const swellCurve = celebProgress < 0.15
          ? easeOutExpo(celebProgress / 0.15)
          : Math.max(0, 1 - (celebProgress - 0.15) / 0.85);
        celebRadius = 3 + swellCurve * 2.5;
        celebBreath = Math.min(celebBreath + swellCurve * 0.3, 1);
      }

      drawEntity(x, y, celebRadius, celebBreath);

      // Draw celebration ripples
      if (celebrationRipples.length > 0) {
        drawCelebrationRipples(x, y, now);
      }

      requestAnimationFrame(animate);
    }

    function drawCelebrationRipples(cx, cy, now) {
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const mood = entity.status.mood ?? 50;

      for (let i = celebrationRipples.length - 1; i >= 0; i--) {
        const ripple = celebrationRipples[i];
        const elapsed = now - ripple.startTime;
        const progress = Math.min(elapsed / ripple.duration, 1);

        if (progress >= 1) continue;

        const maxRadius = 80 + entity.form.density * 1.5;
        const radius = progress * maxRadius;
        const alpha = (1 - progress) * 0.35;
        const hue = pal.hueBase + (mood / 100) * pal.hueRange;
        const sat = pal.satBase + (mood / 100) * pal.satRange;

        ctx.strokeStyle = `hsla(${hue}, ${sat}%, 55%, ${alpha})`;
        ctx.lineWidth = (1 - progress) * 2;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function drawEncounterSparkles(cx, cy, elapsed, progress) {
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const sparkleCount = 12;
      const maxRadius = 150 + progress * 200;

      for (let i = 0; i < sparkleCount; i++) {
        const angle = (i / sparkleCount) * Math.PI * 2 + elapsed * 0.001;
        const dist = progress * maxRadius * (0.5 + 0.5 * Math.sin(i * 1.7 + elapsed * 0.003));
        const sx = cx + Math.cos(angle) * dist;
        const sy = cy + Math.sin(angle) * dist;
        const sparkleAlpha = (1 - progress) * 0.6;
        const hue = pal.hueBase + (i / sparkleCount) * pal.hueRange;
        const size = (1 - progress) * 2;

        ctx.fillStyle = `hsla(${hue}, ${pal.satBase + 20}%, 65%, ${sparkleAlpha})`;
        ctx.beginPath();
        ctx.arc(sx, sy, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function easeOutExpo(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    animate();

    // =====================================================
    // --- Sound Engine (Web Audio API) ---
    // =====================================================

    const SoundEngine = (() => {
      let audioCtx = null;
      let masterGain = null;
      let isEnabled = false;
      let isInitialized = false;
      let soundLoopTimer = null;
      let prevMood = null;
      let prevEnergy = null;

      // Species-specific sound profiles
      const SPECIES_SOUND = {
        vibration: {
          waveform: 'square',
          patternWeight: 3,
          cryWeight: 2,
          basePitch: 220,
          pitchRange: 300,
        },
        geometric: {
          waveform: 'triangle',
          patternWeight: 3,
          cryWeight: 1,
          basePitch: 330,
          pitchRange: 200,
        },
        chromatic: {
          waveform: 'sine',
          patternWeight: 1,
          cryWeight: 3,
          basePitch: 260,
          pitchRange: 250,
        },
        thermal: {
          waveform: 'sine',
          patternWeight: 1,
          cryWeight: 2,
          basePitch: 110,
          pitchRange: 150,
        },
        temporal: {
          waveform: 'triangle',
          patternWeight: 3,
          cryWeight: 1,
          basePitch: 440,
          pitchRange: 180,
        },
        chemical: {
          waveform: 'sawtooth',
          patternWeight: 2,
          cryWeight: 3,
          basePitch: 200,
          pitchRange: 280,
        },
      };

      // Micro-variation: slight random offset
      function vary(value, range) {
        return value + (Math.random() - 0.5) * range;
      }

      // Get species profile
      function getProfile() {
        return SPECIES_SOUND[entity.seed.perception] || SPECIES_SOUND.chromatic;
      }

      // Compute pitch from mood (0-100) -> frequency
      function moodPitch(base, range, mood) {
        // Higher mood = brighter (higher) pitch
        const normalized = (mood ?? 50) / 100;
        return base + normalized * range;
      }

      // Compute interval between sounds from energy
      function energyInterval() {
        const energy = entity.status.energy ?? 50;
        // High energy = shorter intervals (more frequent sounds)
        // Range: 2s (high energy) to 8s (low energy)
        return 2000 + (1 - energy / 100) * 6000;
      }

      // Growth stage affects harmonic richness
      function growthHarmonics() {
        const day = entity.status.growthDay ?? 0;
        if (day < 7) return 0;      // Pure tone only
        if (day < 14) return 1;     // Slight harmonics
        if (day < 30) return 2;     // Moderate
        if (day < 60) return 3;     // Rich
        return 4;                    // Full richness
      }

      // Growth stage affects available sound variety
      function growthSoundLevel() {
        const day = entity.status.growthDay ?? 0;
        if (day < 1) return 0;   // Single tone
        if (day < 7) return 1;   // 2-3 pitches
        if (day < 14) return 2;  // Rhythm + basic cries
        if (day < 30) return 3;  // Patterns and cries differentiate
        if (day < 60) return 4;  // Sound vocabulary
        return 5;                 // Full expression
      }

      // Initialize AudioContext (must be called from user gesture)
      function init() {
        if (isInitialized) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.12; // Subtle ambient volume
        masterGain.connect(audioCtx.destination);
        isInitialized = true;
      }

      // Create an oscillator with optional harmonics
      function createTone(freq, waveform, duration, gainValue, startTime) {
        if (!audioCtx) return;
        const t = startTime || audioCtx.currentTime;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = waveform;
        osc.frequency.setValueAtTime(vary(freq, freq * 0.02), t);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(gainValue, t + Math.min(duration * 0.1, 0.05));
        gain.gain.setValueAtTime(gainValue, t + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);

        // Add harmonics based on growth
        const harmonicLevel = growthHarmonics();
        if (harmonicLevel > 0) {
          for (let h = 1; h <= harmonicLevel; h++) {
            const hOsc = audioCtx.createOscillator();
            const hGain = audioCtx.createGain();
            hOsc.type = waveform;
            hOsc.frequency.setValueAtTime(vary(freq * (h + 1), freq * 0.03), t);
            const hVol = gainValue * (0.15 / (h + 1));
            hGain.gain.setValueAtTime(0, t);
            hGain.gain.linearRampToValueAtTime(hVol, t + Math.min(duration * 0.15, 0.06));
            hGain.gain.setValueAtTime(hVol, t + duration * 0.6);
            hGain.gain.exponentialRampToValueAtTime(0.001, t + duration);
            hOsc.connect(hGain);
            hGain.connect(masterGain);
            hOsc.start(t);
            hOsc.stop(t + duration + 0.05);
          }
        }
      }

      // --- Pattern Sounds ---
      // Short, repeatable, morse-code-like sequences

      // Single pop/blip
      function playPop(freq, startTime) {
        const profile = getProfile();
        const duration = vary(0.08, 0.02);
        createTone(freq, profile.waveform, duration, 0.6, startTime);
      }

      // Greeting: pop-pop, pooon
      function playGreeting() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;

        playPop(freq, t);
        playPop(vary(freq, 10), t + 0.12);
        // pause
        createTone(vary(freq * 0.9, 8), profile.waveform, vary(0.35, 0.05), 0.45, t + 0.4);
      }

      // Thinking: pop pop pop (evenly spaced)
      function playThinking() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const spacing = vary(0.22, 0.03);

        for (let i = 0; i < 3; i++) {
          playPop(vary(freq, 5), t + i * spacing);
        }
      }

      // Agreement: single long tone (pooooon)
      function playAgreement() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        createTone(freq, profile.waveform, vary(0.5, 0.08), 0.4);
      }

      // Excitement: rapid short bursts (popopopopo)
      function playExcitement() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const count = 4 + Math.floor(Math.random() * 3);

        for (let i = 0; i < count; i++) {
          playPop(vary(freq * (1 + i * 0.03), 8), t + i * vary(0.07, 0.01));
        }
      }

      // --- Cries (organic/emotional) ---

      // Happy: rising tone + wobble (pyururu~)
      function playCryHappy() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.6, 0.1);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform === 'square' ? 'square' : 'sine';
        osc.frequency.setValueAtTime(baseFreq * 0.8, t);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.3, t + duration * 0.6);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.1, t + duration);

        // Wobble via LFO
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(vary(8, 2), t);
        lfoGain.gain.setValueAtTime(vary(15, 5), t);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.35, t + 0.04);
        gain.gain.setValueAtTime(0.35, t + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
        lfo.start(t);
        lfo.stop(t + duration + 0.05);
      }

      // Lonely: descending tone + decay (miu...)
      function playCryLonely() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.8, 0.15);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq * 1.2, t);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, t + duration);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Surprised: short irregular vibration (bururuッ)
      function playCrySurprised() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.25, 0.05);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform;
        osc.frequency.setValueAtTime(vary(baseFreq * 1.5, 30), t);

        // Rapid irregular vibrato
        lfo.type = 'sawtooth';
        lfo.frequency.setValueAtTime(vary(25, 8), t);
        lfoGain.gain.setValueAtTime(vary(40, 15), t);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
        lfo.start(t);
        lfo.stop(t + duration + 0.05);
      }

      // Calm: long stable low tone (fuu~~)
      function playCryCalm() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch * 0.6, profile.pitchRange * 0.5, mood);
        const t = audioCtx.currentTime;
        const duration = vary(1.0, 0.2);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(vary(baseFreq, 5), t);
        osc.frequency.linearRampToValueAtTime(vary(baseFreq * 0.98, 3), t + duration);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.2, t + duration * 0.15);
        gain.gain.setValueAtTime(0.2, t + duration * 0.75);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Dormant: very faint, slow single tone
      function playDormantTone() {
        if (!audioCtx) return;
        const profile = getProfile();
        const baseFreq = profile.basePitch * 0.7;
        const t = audioCtx.currentTime;
        const duration = vary(1.5, 0.3);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(vary(baseFreq, 3), t);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.06, t + duration * 0.3);
        gain.gain.setValueAtTime(0.06, t + duration * 0.6);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Awakening: burst of sound activity
      function playAwakeningBurst() {
        if (!audioCtx) return;
        const profile = getProfile();
        const baseFreq = profile.basePitch;
        const t = audioCtx.currentTime;

        // Rising cascade of tones
        const noteCount = 6 + Math.floor(Math.random() * 4);
        for (let i = 0; i < noteCount; i++) {
          const freq = baseFreq * (0.8 + i * 0.15) + vary(0, 10);
          const startOffset = i * vary(0.12, 0.02);
          const dur = vary(0.3, 0.05);
          const vol = 0.25 + (i / noteCount) * 0.3;

          createTone(freq, profile.waveform, dur, Math.min(vol, 0.5), t + startOffset);
        }

        // Followed by a sustained tone
        const sustainStart = t + noteCount * 0.12 + 0.1;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform === 'square' ? 'square' : 'sine';
        osc.frequency.setValueAtTime(baseFreq * 1.5, sustainStart);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.2, sustainStart + 1.5);

        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(4, sustainStart);
        lfoGain.gain.setValueAtTime(8, sustainStart);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0, sustainStart);
        gain.gain.linearRampToValueAtTime(0.4, sustainStart + 0.1);
        gain.gain.setValueAtTime(0.4, sustainStart + 0.8);
        gain.gain.exponentialRampToValueAtTime(0.001, sustainStart + 1.5);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(sustainStart);
        osc.stop(sustainStart + 1.6);
        lfo.start(sustainStart);
        lfo.stop(sustainStart + 1.6);
      }

      // Select a pattern sound based on entity state
      function pickPatternSound() {
        const level = growthSoundLevel();
        const mood = entity.status.mood ?? 50;
        const energy = entity.status.energy ?? 50;
        const curiosity = entity.status.curiosity ?? 50;

        // Day 0: single tone only
        if (level === 0) {
          playAgreement();
          return;
        }

        // Build weighted list based on state
        const options = [];

        // Greeting: moderate mood
        if (level >= 1) options.push({ fn: playGreeting, weight: mood > 40 ? 2 : 1 });
        // Thinking: moderate energy, higher curiosity
        if (level >= 1) options.push({ fn: playThinking, weight: curiosity > 50 ? 3 : 1 });
        // Agreement: calm state
        if (level >= 1) options.push({ fn: playAgreement, weight: mood > 60 ? 2 : 1 });
        // Excitement: high energy + curiosity
        if (level >= 2) options.push({ fn: playExcitement, weight: (energy > 60 && curiosity > 60) ? 4 : 1 });

        const totalWeight = options.reduce((sum, o) => sum + o.weight, 0);
        let r = Math.random() * totalWeight;
        for (const opt of options) {
          r -= opt.weight;
          if (r <= 0) { opt.fn(); return; }
        }
        // fallback
        if (options.length > 0) options[0].fn();
      }

      // Select a cry sound based on entity state
      function pickCrySound() {
        const level = growthSoundLevel();
        const mood = entity.status.mood ?? 50;
        const comfort = entity.status.comfort ?? 50;

        // No cries before day 14
        if (level < 2) return;

        const options = [];

        // Happy: high mood
        options.push({ fn: playCryHappy, weight: mood > 65 ? 4 : 1 });
        // Lonely: low comfort
        options.push({ fn: playCryLonely, weight: comfort < 35 ? 4 : 1 });
        // Surprised: random, low weight
        if (level >= 3) options.push({ fn: playCrySurprised, weight: 1 });
        // Calm: high comfort, moderate mood
        options.push({ fn: playCryCalm, weight: comfort > 60 ? 3 : 1 });

        const totalWeight = options.reduce((sum, o) => sum + o.weight, 0);
        let r = Math.random() * totalWeight;
        for (const opt of options) {
          r -= opt.weight;
          if (r <= 0) { opt.fn(); return; }
        }
      }

      // Detect mood transitions for triggering cries
      function checkMoodTransition() {
        const mood = entity.status.mood ?? 50;
        const energy = entity.status.energy ?? 50;

        if (prevMood !== null) {
          const moodDelta = Math.abs(mood - prevMood);
          const energyDelta = Math.abs(energy - (prevEnergy ?? 50));

          // Significant mood change triggers a cry
          if (moodDelta > 10 || energyDelta > 15) {
            // Small delay so it doesn't overlap with pattern sounds
            setTimeout(() => {
              if (isEnabled && !entity.sulk.isSulking) {
                pickCrySound();
              }
            }, 500 + Math.random() * 1000);
          }
        }

        prevMood = mood;
        prevEnergy = energy;
      }

      // Main sound loop
      function soundLoop() {
        if (!isEnabled || !audioCtx) return;

        // Sulking = silence
        if (entity.sulk.isSulking) {
          scheduleSoundLoop();
          return;
        }

        // Dormant = very faint, infrequent tone
        if (encounterPhase === 'dormant') {
          playDormantTone();
          soundLoopTimer = setTimeout(soundLoop, vary(6000, 2000));
          return;
        }

        // Awakening = burst (played once from triggerAwakening hook)
        // During awakening phase, play excited sounds more frequently
        if (encounterPhase === 'awakening') {
          pickPatternSound();
          soundLoopTimer = setTimeout(soundLoop, vary(800, 200));
          return;
        }

        // Normal operation: decide pattern vs cry based on species weights
        const profile = getProfile();
        const totalWeight = profile.patternWeight + profile.cryWeight;
        const roll = Math.random() * totalWeight;

        if (roll < profile.patternWeight) {
          pickPatternSound();
        } else {
          const level = growthSoundLevel();
          if (level >= 2) {
            pickCrySound();
          } else {
            pickPatternSound(); // fallback if cries not yet available
          }
        }

        scheduleSoundLoop();
      }

      function scheduleSoundLoop() {
        const interval = energyInterval();
        // Add comfort-based silence extension
        const comfort = entity.status.comfort ?? 50;
        const mood = entity.status.mood ?? 50;

        // Low mood + low comfort = longer silence between sounds
        let silenceMultiplier = 1;
        if (mood < 30) silenceMultiplier += 0.5;
        if (comfort < 30) silenceMultiplier += 0.3;

        const finalInterval = vary(interval * silenceMultiplier, interval * 0.2);
        soundLoopTimer = setTimeout(soundLoop, Math.max(finalInterval, 1500));
      }

      // Enable/disable
      function enable() {
        if (!isInitialized) init();
        isEnabled = true;
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        soundLoop();
      }

      function disable() {
        isEnabled = false;
        if (soundLoopTimer) {
          clearTimeout(soundLoopTimer);
          soundLoopTimer = null;
        }
      }

      function toggle() {
        if (isEnabled) {
          disable();
        } else {
          enable();
        }
        return isEnabled;
      }

      // Called when awakening is triggered (from the existing triggerAwakening)
      function onAwakening() {
        if (!isEnabled || !audioCtx) return;
        playAwakeningBurst();
      }

      // Milestone celebration: gentle ascending chime
      function playMilestoneCelebration() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;

        // Three ascending tones with gentle decay — like a soft chime
        const notes = [1.0, 1.25, 1.5];
        notes.forEach((ratio, i) => {
          const freq = baseFreq * ratio;
          const start = t + i * 0.35;
          const dur = 0.8 - i * 0.1;

          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(vary(freq, 3), start);

          gain.gain.setValueAtTime(0, start);
          gain.gain.linearRampToValueAtTime(0.3, start + 0.05);
          gain.gain.setValueAtTime(0.3, start + dur * 0.4);
          gain.gain.exponentialRampToValueAtTime(0.001, start + dur);

          osc.connect(gain);
          gain.connect(masterGain);
          osc.start(start);
          osc.stop(start + dur + 0.05);

          // Soft harmonic layer
          if (growthHarmonics() > 0) {
            const hOsc = audioCtx.createOscillator();
            const hGain = audioCtx.createGain();
            hOsc.type = 'sine';
            hOsc.frequency.setValueAtTime(freq * 2, start);
            hGain.gain.setValueAtTime(0, start);
            hGain.gain.linearRampToValueAtTime(0.08, start + 0.06);
            hGain.gain.exponentialRampToValueAtTime(0.001, start + dur * 0.8);
            hOsc.connect(hGain);
            hGain.connect(masterGain);
            hOsc.start(start);
            hOsc.stop(start + dur + 0.05);
          }
        });
      }

      function onMilestone() {
        if (!isEnabled || !audioCtx) return;
        playMilestoneCelebration();
      }

      return {
        init,
        enable,
        disable,
        toggle,
        isEnabled: () => isEnabled,
        checkMoodTransition,
        onAwakening,
        onMilestone,
        growthSoundLevel,
      };
    })();

    // --- Sound Toggle Button ---
    const soundToggle = document.getElementById('sound-toggle');

    soundToggle.addEventListener('click', () => {
      const enabled = SoundEngine.toggle();
      soundToggle.classList.toggle('muted', !enabled);
      soundToggle.title = enabled ? 'Mute sound' : 'Toggle sound';
    });

    // --- Sound Growth Level Indicator ---
    const soundGrowthEl = document.getElementById('sound-growth');
    const soundGrowthDots = soundGrowthEl.querySelectorAll('.sound-growth-dot');
    const SOUND_LEVEL_LABELS = [
      'Single tone',
      'Single tone',
      'Pitch variety',
      'Rhythm + cries',
      'Sound vocabulary',
      'Sound-language correspondence',
    ];

    function updateSoundGrowthIndicator() {
      const level = SoundEngine.growthSoundLevel();
      const displayLevel = Math.max(level, 1); // Show at least level 1
      soundGrowthDots.forEach((dot, i) => {
        dot.classList.toggle('filled', i < displayLevel);
      });
      soundGrowthEl.title = 'Sound growth: Level ' + displayLevel + ' \u2014 ' + SOUND_LEVEL_LABELS[level];
    }
    updateSoundGrowthIndicator();

    // Hook mood transition checks into the fetch cycle
    const _origFetchState = fetchState;
    fetchState = async function() {
      await _origFetchState();
      SoundEngine.checkMoodTransition();
      updateSoundGrowthIndicator();
    };

    // Hook awakening sound into the existing triggerAwakening
    const _origTriggerAwakening = triggerAwakening;
    triggerAwakening = function(data) {
      _origTriggerAwakening(data);
      SoundEngine.onAwakening();
    };

    // --- Coexistence Log ---
    const logToggle = document.getElementById('log-toggle');
    const logPanel = document.getElementById('coexistence-log');
    const logContent = document.getElementById('log-content');

    logToggle.addEventListener('click', () => {
      logPanel.classList.toggle('open');
      if (logPanel.classList.contains('open')) {
        fetchCoexistenceLog();
      }
    });

    // --- Senses Panel ---
    const sensesToggle = document.getElementById('senses-toggle');
    const sensesPanel = document.getElementById('senses-panel');
    const sensesContent = document.getElementById('senses-content');

    sensesToggle.addEventListener('click', () => {
      sensesPanel.classList.toggle('open');
      if (sensesPanel.classList.contains('open')) {
        fetchPerception();
      }
    });

    async function fetchPerception() {
      try {
        const res = await fetch('/api/perception');
        if (!res.ok) return;
        const d = await res.json();

        if (!d.hasPerception || d.perceptions.length === 0) {
          sensesContent.innerHTML = '<span class="sense-empty">No sensors detected.<br>You sense only your own existence.</span>';
          return;
        }

        // Build perception level dots (5 levels: 0-4)
        let levelDots = '<div class="sense-level">';
        for (let i = 0; i < 5; i++) {
          levelDots += `<div class="sense-level-dot${i <= d.perceptionLevel ? ' active' : ''}"></div>`;
        }
        levelDots += '</div>';

        // Species label
        const speciesLabel = d.species ? `<div class="log-label" style="margin-bottom:12px">${d.species} · level ${d.perceptionLevel}</div>${levelDots}` : '';

        // Perception items
        const items = d.perceptions.map(p =>
          `<div class="sense-item"><div class="sense-description">${escapeHtml(p)}</div></div>`
        ).join('');

        sensesContent.innerHTML = `${speciesLabel}<div class="log-divider"></div>${items}`;
      } catch {
        sensesContent.innerHTML = '<span class="sense-empty">· · ·</span>';
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Auto-refresh perception when panel is open
    setInterval(() => {
      if (sensesPanel.classList.contains('open')) {
        fetchPerception();
      }
    }, 5000);

    // --- Diary Panel (two-column: date list + content viewer) ---
    const diaryToggle = document.getElementById('diary-toggle');
    const diaryPanel = document.getElementById('diary-panel');
    const diaryDateListEl = document.getElementById('diary-date-list');
    const diaryContentArea = document.getElementById('diary-content-area');
    let diaryDates = [];
    let diarySelectedDate = null;
    let diaryRefreshTimer = null;

    diaryToggle.addEventListener('click', () => {
      diaryPanel.classList.toggle('open');
      if (diaryPanel.classList.contains('open')) {
        fetchDiaryList();
        // Auto-refresh date list every 60 seconds
        if (!diaryRefreshTimer) {
          diaryRefreshTimer = setInterval(() => {
            if (diaryPanel.classList.contains('open')) {
              fetchDiaryList(true); // preserve selection
            }
          }, 60000);
        }
      }
    });

    async function fetchDiaryList(preserveSelection) {
      try {
        const res = await fetch('/api/diary');
        if (!res.ok) return;
        const d = await res.json();
        diaryDates = d.dates || [];

        if (diaryDates.length === 0) {
          diaryDateListEl.innerHTML = '';
          diaryContentArea.innerHTML = '<span class="diary-empty">No entries yet.</span>';
          return;
        }

        renderDateList();

        // Select the previously selected date if preserving, or the newest
        if (preserveSelection && diarySelectedDate && diaryDates.includes(diarySelectedDate)) {
          selectDiaryDate(diarySelectedDate);
        } else {
          selectDiaryDate(diaryDates[0]);
        }
      } catch {
        diaryContentArea.innerHTML = '<span class="diary-empty">· · ·</span>';
      }
    }

    function renderDateList() {
      diaryDateListEl.innerHTML = diaryDates.map(date => {
        const isActive = date === diarySelectedDate;
        return `<button class="diary-date-item${isActive ? ' active' : ''}" data-date="${escapeHtml(date)}">${escapeHtml(date)}</button>`;
      }).join('');

      // Attach click handlers
      diaryDateListEl.querySelectorAll('.diary-date-item').forEach(btn => {
        btn.addEventListener('click', () => {
          selectDiaryDate(btn.dataset.date);
        });
      });
    }

    function selectDiaryDate(date) {
      diarySelectedDate = date;
      // Update active state in list
      diaryDateListEl.querySelectorAll('.diary-date-item').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.date === date);
      });
      fetchDiaryEntry(date);
    }

    async function fetchDiaryEntry(date) {
      try {
        const res = await fetch(`/api/diary?date=${date}`);
        if (!res.ok) {
          diaryContentArea.innerHTML = '<span class="diary-empty">No entry for this date.</span>';
          return;
        }
        const d = await res.json();
        const raw = (d.content || '').replace(/<!-- .+? -->/g, '').trim();

        if (!raw) {
          diaryContentArea.innerHTML = `<div class="diary-content-date">${escapeHtml(date)}</div><span class="diary-empty">Empty entry.</span>`;
          return;
        }

        diaryContentArea.innerHTML = `
          <div class="diary-content-date">${escapeHtml(date)}</div>
          <div class="diary-body">${renderMarkdown(raw)}</div>
        `;
      } catch {
        diaryContentArea.innerHTML = '<span class="diary-empty">Failed to load diary.</span>';
      }
    }

    // Simple markdown to HTML converter (headers, bold, italic, bullet/numbered lists)
    function renderMarkdown(md) {
      const lines = md.split('\n');
      let html = '';
      let inUl = false;
      let inOl = false;

      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];

        // Close open lists if this line is not a list item
        const isBullet = /^(\s*)[-*+]\s+/.test(line);
        const isOrdered = /^(\s*)\d+\.\s+/.test(line);

        if (!isBullet && inUl) { html += '</ul>'; inUl = false; }
        if (!isOrdered && inOl) { html += '</ol>'; inOl = false; }

        // Headers
        if (/^### (.+)$/.test(line)) {
          html += '<h3>' + inlineFormat(escapeHtml(line.replace(/^### /, ''))) + '</h3>';
          continue;
        }
        if (/^## (.+)$/.test(line)) {
          html += '<h2>' + inlineFormat(escapeHtml(line.replace(/^## /, ''))) + '</h2>';
          continue;
        }
        if (/^# (.+)$/.test(line)) {
          html += '<h1>' + inlineFormat(escapeHtml(line.replace(/^# /, ''))) + '</h1>';
          continue;
        }

        // Bullet lists
        if (isBullet) {
          if (!inUl) { html += '<ul>'; inUl = true; }
          const content = line.replace(/^(\s*)[-*+]\s+/, '');
          html += '<li>' + inlineFormat(escapeHtml(content)) + '</li>';
          continue;
        }

        // Ordered lists
        if (isOrdered) {
          if (!inOl) { html += '<ol>'; inOl = true; }
          const content = line.replace(/^(\s*)\d+\.\s+/, '');
          html += '<li>' + inlineFormat(escapeHtml(content)) + '</li>';
          continue;
        }

        // Empty lines become paragraph breaks
        if (line.trim() === '') {
          html += '<br>';
          continue;
        }

        // Normal text as paragraph
        html += '<p>' + inlineFormat(escapeHtml(line)) + '</p>';
      }

      // Close any open lists
      if (inUl) html += '</ul>';
      if (inOl) html += '</ol>';

      return html;
    }

    // Inline formatting: **bold**, *italic*, __bold__, _italic_
    function inlineFormat(text) {
      // Bold: **text** or __text__
      text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      text = text.replace(/__(.+?)__/g, '<strong>$1</strong>');
      // Italic: *text* or _text_ (but not inside words for underscore)
      text = text.replace(/\*(.+?)\*/g, '<em>$1</em>');
      text = text.replace(/(?<!\w)_(.+?)_(?!\w)/g, '<em>$1</em>');
      return text;
    }

    // --- Error Log Panel ---
    const errorlogToggle = document.getElementById('errorlog-toggle');
    const errorlogPanel = document.getElementById('errorlog-panel');
    const errorlogContent = document.getElementById('errorlog-content');

    errorlogToggle.addEventListener('click', () => {
      errorlogPanel.classList.toggle('open');
      if (errorlogPanel.classList.contains('open')) {
        fetchErrorLog();
      }
    });

    async function fetchErrorLog() {
      try {
        const res = await fetch('/api/logs?limit=50');
        if (!res.ok) return;
        const d = await res.json();
        const entries = d.entries || [];
        if (entries.length === 0) {
          errorlogContent.innerHTML = '<span class="errorlog-empty">No log entries.</span>';
          return;
        }
        errorlogContent.innerHTML = entries.map(e => {
          const time = e.timestamp ? e.timestamp.replace('T', ' ').slice(0, 19) : '—';
          return `<div class="log-entry"><span class="log-entry-time">${escapeHtml(time)}</span><span class="log-entry-level ${escapeHtml(e.level)}">${escapeHtml(e.level)}</span><span class="log-entry-msg">${escapeHtml(e.message)}</span></div>`;
        }).join('');
      } catch {
        errorlogContent.innerHTML = '<span class="errorlog-empty">· · ·</span>';
      }
    }

    // Auto-refresh error log when panel is open
    setInterval(() => {
      if (errorlogPanel.classList.contains('open')) {
        fetchErrorLog();
      }
    }, 10000);

    // --- Milestone Timeline Panel ---
    const milestoneToggle = document.getElementById('milestone-toggle');
    const milestonePanel = document.getElementById('milestone-panel');
    const milestoneContent = document.getElementById('milestone-content');

    milestoneToggle.addEventListener('click', () => {
      milestonePanel.classList.toggle('open');
      if (milestonePanel.classList.contains('open')) {
        fetchMilestones();
      }
    });

    async function fetchMilestones() {
      try {
        const res = await fetch('/api/milestones');
        if (!res.ok) return;
        const d = await res.json();
        const milestones = d.milestones || [];
        const stage = d.stage || 'newborn';

        if (milestones.length === 0) {
          milestoneContent.innerHTML = `
            <div class="milestone-stage">${escapeHtml(stage)}</div>
            <span class="milestone-empty">No milestones yet.</span>
          `;
          return;
        }

        const timelineItems = milestones.map(m => {
          const parts = m.label.split(' \u2014 ');
          const name = parts.length > 1 ? parts[1] : m.label;
          const title = parts[0] || '';
          return `<div class="milestone-item">
            <div class="milestone-day">Day ${m.achievedDay}</div>
            <div class="milestone-name">${escapeHtml(title)}</div>
            <div class="milestone-name" style="color:rgba(255,255,255,0.3);font-size:11px">${escapeHtml(name)}</div>
          </div>`;
        }).join('');

        milestoneContent.innerHTML = `
          <div class="milestone-stage">${escapeHtml(stage)}</div>
          <div class="milestone-timeline">${timelineItems}</div>
        `;
      } catch {
        milestoneContent.innerHTML = '<span class="milestone-empty">· · ·</span>';
      }
    }

    // Auto-refresh milestones when panel is open
    setInterval(() => {
      if (milestonePanel.classList.contains('open')) {
        fetchMilestones();
      }
    }, 15000);

    async function fetchCoexistenceLog() {
      try {
        const res = await fetch('/api/coexistence');
        if (!res.ok) return;
        const d = await res.json();

        const silenceText = d.silenceHours === null
          ? '—'
          : d.silenceHours < 1
            ? `${Math.round(d.silenceHours * 60)} min`
            : d.silenceHours < 24
              ? `${Math.round(d.silenceHours)} hrs`
              : `${Math.round(d.silenceHours / 24)} days`;

        logContent.innerHTML = `
          <div class="log-field">
            <div class="log-label">Days together</div>
            <div class="log-value">${d.daysTogether}<span class="log-unit">days</span></div>
          </div>
          <div class="log-field">
            <div class="log-label">Messages sent</div>
            <div class="log-value">${d.totalInteractions}</div>
          </div>
          <div class="log-field">
            <div class="log-label">Active days</div>
            <div class="log-value">${d.activeDays}<span class="log-unit">/ ${d.daysTogether || '—'}</span></div>
          </div>
          <div class="log-divider"></div>
          <div class="log-field">
            <div class="log-label">Current silence</div>
            <div class="log-value log-silence">${silenceText}</div>
          </div>
          <div class="log-field">
            <div class="log-label">Diary entries</div>
            <div class="log-value">${d.diaryEntries}</div>
          </div>
        `;
      } catch {
        logContent.textContent = '—';
      }
    }
  </script>
</body>
</html>

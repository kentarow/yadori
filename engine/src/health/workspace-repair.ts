/**
 * Workspace Repair â€” Detect and fix recoverable workspace issues.
 *
 * Non-destructive: only recreates missing files from state.json or templates.
 * Never overwrites existing data. Never touches SEED.md (immutable).
 */

import { readFile, writeFile, mkdir, access } from "node:fs/promises";
import { join } from "node:path";

export interface RepairAction {
  file: string;
  action: "created" | "skipped";
  reason: string;
}

export interface RepairResult {
  actions: RepairAction[];
  repaired: number;
  skipped: number;
}

/**
 * Required directories in the workspace.
 */
const REQUIRED_DIRS = [
  "memory",
  "memory/weekly",
  "memory/monthly",
  "diary",
  "growth",
  "growth/portraits",
];

/**
 * Repair missing directories and regenerable files.
 * Uses state.json as the source of truth for STATUS.md, LANGUAGE.md, etc.
 */
export async function repairWorkspace(workspaceRoot: string): Promise<RepairResult> {
  const actions: RepairAction[] = [];

  // Step 1: Ensure directories exist
  for (const dir of REQUIRED_DIRS) {
    const fullPath = join(workspaceRoot, dir);
    try {
      await access(fullPath);
    } catch {
      await mkdir(fullPath, { recursive: true, mode: 0o700 });
      actions.push({ file: dir + "/", action: "created", reason: "Missing directory" });
    }
  }

  // Step 2: Try to load state.json for regeneration
  let state: Record<string, unknown> | null = null;
  for (const filename of ["state.json", "__state.json"]) {
    try {
      const content = await readFile(join(workspaceRoot, filename), "utf-8");
      state = JSON.parse(content) as Record<string, unknown>;
      break;
    } catch {
      continue;
    }
  }

  // Step 3: Regenerate missing files from state.json if available
  if (state) {
    // STATUS.md
    await regenerateIfMissing(
      workspaceRoot, "STATUS.md", actions,
      () => regenerateStatusMd(state!),
    );

    // MEMORY.md
    await regenerateIfMissing(
      workspaceRoot, "MEMORY.md", actions,
      () => "# MEMORY\n\n## Hot Memory (Recent)\n\nNo recent memories.\n\n## Warm Memory (This Week)\n\n<!-- No weekly summaries yet -->\n\n## Notes\n\n<!-- Important observations that persist across sessions -->\n",
    );

    // LANGUAGE.md
    await regenerateIfMissing(
      workspaceRoot, "LANGUAGE.md", actions,
      () => regenerateLanguageMd(state!),
    );

    // FORM.md
    await regenerateIfMissing(
      workspaceRoot, "FORM.md", actions,
      () => regenerateFormMd(state!),
    );
  }

  // Step 4: Create minimal SOUL.md if missing (not from state, from template)
  await regenerateIfMissing(
    workspaceRoot, "SOUL.md", actions,
    () => "# SOUL\n\n> Personality definition regenerated by repair.\n> This file can be self-modified by the entity.\n",
  );

  // Step 5: HEARTBEAT.md
  await regenerateIfMissing(
    workspaceRoot, "HEARTBEAT.md", actions,
    () => `# HEARTBEAT

## Autonomous Actions

- [ ] Check mood and comfort levels
- [ ] Review recent memory
- [ ] Update status based on time passed
- [ ] Write diary if evening
`,
  );

  const repaired = actions.filter((a) => a.action === "created").length;
  const skipped = actions.filter((a) => a.action === "skipped").length;

  return { actions, repaired, skipped };
}

async function regenerateIfMissing(
  root: string,
  filename: string,
  actions: RepairAction[],
  generate: () => string,
): Promise<void> {
  const path = join(root, filename);
  try {
    await access(path);
    // File exists, skip
  } catch {
    const content = generate();
    await writeFile(path, content, "utf-8");
    actions.push({ file: filename, action: "created", reason: "Regenerated from state" });
  }
}

function regenerateStatusMd(state: Record<string, unknown>): string {
  const status = (state.status ?? {}) as Record<string, unknown>;
  return `# STATUS

## Current State

- **mood**: ${status.mood ?? 50}
- **energy**: ${status.energy ?? 50}
- **curiosity**: ${status.curiosity ?? 50}
- **comfort**: ${status.comfort ?? 50}

## Language

- **level**: ${status.languageLevel ?? 0}

## Perception

- **perception_level**: ${status.perceptionLevel ?? 0}

## Growth

- **day**: ${status.growthDay ?? 0}
- **last_interaction**: ${status.lastInteraction ?? "never"}
`;
}

function regenerateLanguageMd(state: Record<string, unknown>): string {
  const language = (state.language ?? {}) as Record<string, unknown>;
  const level = (language.level ?? 0) as number;
  const labels = ["Symbols Only", "Pattern Establishment", "Bridge to Language", "Unique Language", "Advanced Operation"];
  return `# LANGUAGE

## Current Level

- **level**: ${level} (${labels[level] ?? "Unknown"})

## Statistics

- **totalInteractions**: ${language.totalInteractions ?? 0}
- **uniqueSymbols**: ${(language.uniqueSymbols as string[] | undefined)?.length ?? 0}

> Regenerated by workspace repair.
`;
}

function regenerateFormMd(state: Record<string, unknown>): string {
  const form = (state.form ?? {}) as Record<string, unknown>;
  return `# FORM

## Self-Perceived Form

- **baseForm**: ${form.baseForm ?? "unknown"}
- **density**: ${form.density ?? 50}
- **complexity**: ${form.complexity ?? 30}
- **stability**: ${form.stability ?? 50}

> Regenerated by workspace repair.
`;
}

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YADORI</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      cursor: none;
      font-family: monospace;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.15);
      font-size: 11px;
      line-height: 1.6;
      pointer-events: none;
      transition: color 0.5s;
      white-space: pre;
    }
    body:hover #info { color: rgba(255, 255, 255, 0.4); }
    #milestones {
      position: fixed;
      top: 20px;
      right: 20px;
      color: rgba(255, 255, 255, 0);
      font-size: 12px;
      line-height: 1.8;
      text-align: right;
      pointer-events: none;
      transition: color 3s;
    }
    #milestones.show { color: rgba(255, 255, 255, 0.35); }
    #sulk-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      transition: background 2s;
    }
    #encounter-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 10;
    }
    #encounter-expression {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0);
      font-size: 28px;
      letter-spacing: 8px;
      text-align: center;
      pointer-events: none;
      z-index: 11;
      transition: color 2s, letter-spacing 3s, font-size 2s;
      white-space: nowrap;
    }
    #encounter-expression.reveal {
      color: rgba(255, 255, 255, 0.9);
      letter-spacing: 16px;
      font-size: 36px;
    }
    #encounter-expression.fade {
      color: rgba(255, 255, 255, 0);
      letter-spacing: 24px;
    }
    #dormant-text {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0);
      font-size: 12px;
      pointer-events: none;
      z-index: 5;
      transition: color 3s;
    }
    #dormant-text.show {
      color: rgba(255, 255, 255, 0.15);
    }

    /* Coexistence Log */
    #coexistence-log {
      position: fixed;
      top: 0; right: 0;
      width: 280px;
      height: 100vh;
      padding: 40px 28px;
      background: rgba(0, 0, 0, 0.85);
      border-left: 1px solid rgba(255, 255, 255, 0.06);
      transform: translateX(100%);
      transition: transform 0.4s ease;
      z-index: 20;
      cursor: default;
      overflow-y: auto;
    }
    #coexistence-log.open { transform: translateX(0); }

    #coexistence-log h2 {
      font-size: 10px;
      font-weight: normal;
      letter-spacing: 4px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.25);
      margin-bottom: 32px;
    }

    .log-field {
      margin-bottom: 20px;
    }
    .log-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.25);
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .log-value {
      font-size: 20px;
      color: rgba(255, 255, 255, 0.6);
      font-family: 'Courier New', monospace;
    }
    .log-unit {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.2);
      margin-left: 4px;
    }
    .log-divider {
      width: 40px;
      height: 1px;
      background: rgba(255, 255, 255, 0.06);
      margin: 24px 0;
    }
    .log-silence {
      font-size: 14px;
    }

    #log-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 24px;
      height: 24px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
    }
    body:hover #log-toggle { opacity: 0.3; }
    #log-toggle:hover { opacity: 0.6 !important; }
    #log-toggle svg { width: 24px; height: 24px; }

    /* Sound toggle */
    #sound-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 28px;
      height: 28px;
      cursor: pointer;
      z-index: 21;
      opacity: 0;
      transition: opacity 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    body:hover #sound-toggle { opacity: 0.3; }
    #sound-toggle:hover { opacity: 0.6 !important; }
    #sound-toggle svg { width: 22px; height: 22px; }
    #sound-toggle.muted svg .sound-wave { opacity: 0; }
    #sound-toggle.muted::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 20px;
      background: rgba(255, 255, 255, 0.6);
      transform: rotate(45deg);
      top: 4px;
      left: 13px;
    }
  </style>
</head>
<body>
  <div id="sulk-overlay"></div>
  <div id="encounter-overlay"></div>
  <div id="encounter-expression"></div>
  <div id="dormant-text"></div>
  <canvas id="canvas"></canvas>
  <div id="info"></div>
  <div id="milestones"></div>

  <div id="log-toggle" title="Coexistence Log">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <rect x="3" y="3" width="18" height="18" rx="2"/>
      <line x1="8" y1="8" x2="16" y2="8"/>
      <line x1="8" y1="12" x2="16" y2="12"/>
      <line x1="8" y1="16" x2="12" y2="16"/>
    </svg>
  </div>
  <div id="sound-toggle" class="muted" title="Toggle sound">
    <svg viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="1.5">
      <path d="M11 5L6 9H2v6h4l5 4V5z"/>
      <path class="sound-wave" d="M15.54 8.46a5 5 0 010 7.07"/>
      <path class="sound-wave" d="M19.07 4.93a10 10 0 010 14.14"/>
    </svg>
  </div>
  <div id="coexistence-log">
    <h2>Coexistence Log</h2>
    <div id="log-content">· · ·</div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const infoEl = document.getElementById('info');
    const milestonesEl = document.getElementById('milestones');
    const sulkOverlay = document.getElementById('sulk-overlay');
    const encounterOverlay = document.getElementById('encounter-overlay');
    const encounterExpr = document.getElementById('encounter-expression');
    const dormantText = document.getElementById('dormant-text');

    // --- Full entity state ---
    const entity = {
      status: { mood: 50, energy: 50, curiosity: 70, comfort: 50, growthDay: 0, languageLevel: 0 },
      seed: { perception: 'chromatic', form: 'light-particles', temperament: 'curious-cautious' },
      form: { baseForm: 'light-particles', density: 5, complexity: 3, stability: 15, awareness: false },
      sulk: { isSulking: false, severity: 'none' },
      growth: { stage: 'newborn', milestones: [] },
      language: { totalInteractions: 0 },
    };

    // --- First Encounter state ---
    let prevInteractions = -1; // -1 = unknown yet
    let encounterPhase = 'none'; // 'none' | 'dormant' | 'awakening' | 'afterglow' | 'done'
    let awakeningStartTime = 0;
    const AWAKENING_DURATION = 8000; // 8 seconds of awakening animation
    const AFTERGLOW_DURATION = 10000; // 10 seconds of afterglow

    // --- Perception-based color palettes ---
    const PALETTES = {
      chromatic:  { hueBase: 20,  hueRange: 30, satBase: 60, satRange: 40 },
      vibration:  { hueBase: 250, hueRange: 40, satBase: 50, satRange: 30 },
      geometric:  { hueBase: 180, hueRange: 20, satBase: 30, satRange: 40 },
      thermal:    { hueBase: 0,   hueRange: 40, satBase: 70, satRange: 30 },
      temporal:   { hueBase: 210, hueRange: 50, satBase: 40, satRange: 30 },
      chemical:   { hueBase: 90,  hueRange: 40, satBase: 50, satRange: 40 },
    };

    // --- Form-based rendering parameters ---
    const FORM_PARAMS = {
      'light-particles': { shape: 'circle', trailAlpha: 0.12 },
      'fluid':           { shape: 'circle', trailAlpha: 0.06 },
      'crystal':         { shape: 'diamond', trailAlpha: 0.18 },
      'sound-echo':      { shape: 'ring',   trailAlpha: 0.08 },
      'mist':            { shape: 'circle', trailAlpha: 0.04 },
      'geometric-cluster': { shape: 'square', trailAlpha: 0.15 },
    };

    // Poll entity state every 3 seconds
    async function fetchState() {
      try {
        const res = await fetch('/api/entity');
        if (!res.ok) return;
        const data = await res.json();

        if (data.status) {
          entity.status = { ...entity.status, ...data.status };
        }
        if (data.seed) {
          entity.seed = { ...entity.seed, ...data.seed };
        }
        if (data.form) {
          entity.form = { ...entity.form, ...data.form };
        }
        if (data.sulk) {
          entity.sulk = { ...entity.sulk, ...data.sulk };
        }
        if (data.growth) {
          entity.growth = { ...entity.growth, ...data.growth };
        }
        if (data.language) {
          entity.language = { ...entity.language, ...data.language };
        }

        // --- Detect first encounter transition ---
        const currentInteractions = entity.language.totalInteractions ?? 0;
        if (prevInteractions === -1) {
          // First poll: set state
          prevInteractions = currentInteractions;
          if (currentInteractions === 0) {
            encounterPhase = 'dormant';
            dormantText.textContent = '· · · waiting · · ·';
            dormantText.classList.add('show');
          } else {
            encounterPhase = 'done';
          }
        } else if (prevInteractions === 0 && currentInteractions >= 1) {
          // The transition happened!
          triggerAwakening(data);
        }
        prevInteractions = currentInteractions;

        updateInfo();
        updateSulkOverlay();
        updateMilestones();
        updateDormantState();
      } catch { /* server not available */ }
    }
    fetchState();
    setInterval(fetchState, 3000);

    function triggerAwakening(data) {
      encounterPhase = 'awakening';
      awakeningStartTime = performance.now();

      // Hide dormant text
      dormantText.classList.remove('show');

      // Flash the encounter overlay
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const hue = pal.hueBase + pal.hueRange / 2;
      encounterOverlay.style.background = `radial-gradient(circle at 50% 50%, hsla(${hue}, 80%, 60%, 0.4), transparent 70%)`;
      encounterOverlay.style.opacity = '1';

      // Generate the first encounter expression for display
      const expressions = generateEncounterExpression(entity.seed.perception, entity.seed.temperament);
      encounterExpr.textContent = expressions;

      // Phase 1: Reveal expression (after 1.5s flash)
      setTimeout(() => {
        encounterExpr.classList.add('reveal');
      }, 1500);

      // Phase 2: Fade overlay
      setTimeout(() => {
        encounterOverlay.style.opacity = '0';
      }, 3000);

      // Phase 3: Expression begins fading
      setTimeout(() => {
        encounterExpr.classList.remove('reveal');
        encounterExpr.classList.add('fade');
        encounterPhase = 'afterglow';
      }, AWAKENING_DURATION);

      // Phase 4: Complete
      setTimeout(() => {
        encounterExpr.classList.remove('fade');
        encounterExpr.textContent = '';
        encounterPhase = 'done';
      }, AWAKENING_DURATION + AFTERGLOW_DURATION);
    }

    // Generate a visual expression matching the engine's first encounter output
    function generateEncounterExpression(perception, temperament) {
      const speciesSymbols = {
        chromatic:  { core: ['◎', '○', '☆'], other: '☆' },
        vibration:  { core: ['◈', '◇', '△'], other: '△' },
        geometric:  { core: ['□', '△', '◇'], other: '◇' },
        thermal:    { core: ['○', '◎'],       other: '◎' },
        temporal:   { core: ['○', '◉'],       other: '◉' },
        chemical:   { core: ['◆', '◈', '★'], other: '★' },
      };
      const sp = speciesSymbols[perception] || speciesSymbols.chromatic;

      switch (temperament) {
        case 'curious-cautious':
          return sp.core.join('  ') + '   ' + sp.other;
        case 'bold-impulsive':
          return sp.core.join('') + ' ' + sp.other + ' ' + sp.core.join('');
        case 'calm-observant':
          return '      ' + sp.core[0] + '      ' + sp.other;
        case 'restless-exploratory':
          return sp.core.map(s => s + sp.other).join(' ');
        default:
          return sp.core.join(' ') + ' ' + sp.other;
      }
    }

    function updateDormantState() {
      if (encounterPhase !== 'dormant') return;
      dormantText.textContent = '· · · waiting · · ·';
      dormantText.classList.add('show');
    }

    function updateInfo() {
      const s = entity.status;
      const g = entity.growth;
      infoEl.textContent = `day ${s.growthDay} · ${g.stage} · ${entity.seed.perception}`;
    }

    function updateSulkOverlay() {
      if (entity.sulk.isSulking) {
        const opacity = entity.sulk.severity === 'severe' ? 0.4 :
                        entity.sulk.severity === 'moderate' ? 0.2 : 0.1;
        sulkOverlay.style.background = `rgba(0, 0, 30, ${opacity})`;
      } else {
        sulkOverlay.style.background = 'transparent';
      }
    }

    function updateMilestones() {
      if (!entity.growth.milestones || entity.growth.milestones.length === 0) return;
      const latest = entity.growth.milestones.slice(-3);
      milestonesEl.innerHTML = latest.map(m =>
        `Day ${m.achievedDay}: ${m.label.split(' — ')[0]}`
      ).join('<br>');
      milestonesEl.classList.add('show');
    }

    // --- Resize ---
    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Particle ---
    const particle = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      phase: Math.random() * Math.PI * 2,
      driftPhaseX: Math.random() * Math.PI * 2,
      driftPhaseY: Math.random() * Math.PI * 2,
    };

    // --- Color from perception + mood ---
    function getColor(mood, alpha) {
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const hue = pal.hueBase + (mood / 100) * pal.hueRange;
      const sat = pal.satBase + (mood / 100) * pal.satRange;
      const light = 40 + (mood / 100) * 30;
      return `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
    }

    // --- Draw entity based on form ---
    function drawEntity(x, y, baseRadius, breathAlpha) {
      const form = FORM_PARAMS[entity.form.baseForm] || FORM_PARAMS['light-particles'];
      const mood = entity.status.mood;
      const density = entity.form.density;
      const complexity = entity.form.complexity;

      // Radius scales with density
      const densityScale = 0.5 + (density / 100) * 1.5;
      const radius = baseRadius * densityScale;

      // Number of glow layers scales with complexity
      const layerCount = 3 + Math.floor((complexity / 100) * 5);

      for (let i = layerCount - 1; i >= 0; i--) {
        const t = i / layerCount;
        const layerScale = 1 + t * (8 + complexity / 15);
        const layerAlpha = (1 - t * 0.85) * breathAlpha * 0.6;
        const r = radius * layerScale;

        if (form.shape === 'diamond') {
          drawDiamond(x, y, r, getColor(mood, layerAlpha));
        } else if (form.shape === 'ring') {
          drawRing(x, y, r, getColor(mood, layerAlpha), layerAlpha);
        } else if (form.shape === 'square') {
          drawSquare(x, y, r, getColor(mood, layerAlpha));
        } else {
          drawCircleGlow(x, y, r, mood, layerAlpha);
        }
      }

      // Sulking: dark core
      if (entity.sulk.isSulking) {
        const sulkAlpha = entity.sulk.severity === 'severe' ? 0.6 :
                          entity.sulk.severity === 'moderate' ? 0.3 : 0.15;
        ctx.fillStyle = `rgba(0, 0, 20, ${sulkAlpha})`;
        ctx.beginPath();
        ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCircleGlow(x, y, r, mood, alpha) {
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      gradient.addColorStop(0, getColor(mood, alpha));
      gradient.addColorStop(1, getColor(mood, 0));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawDiamond(x, y, r, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x, y - r);
      ctx.lineTo(x + r * 0.6, y);
      ctx.lineTo(x, y + r);
      ctx.lineTo(x - r * 0.6, y);
      ctx.closePath();
      ctx.fill();
    }

    function drawRing(x, y, r, color, alpha) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 1 + alpha * 3;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawSquare(x, y, r, color) {
      ctx.fillStyle = color;
      const half = r * 0.7;
      ctx.fillRect(x - half, y - half, half * 2, half * 2);
    }

    // --- Animation ---
    let time = 0;

    function animate() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const form = FORM_PARAMS[entity.form.baseForm] || FORM_PARAMS['light-particles'];
      const now = performance.now();

      // Clear with trail (form-specific trail length)
      ctx.fillStyle = `rgba(0, 0, 0, ${form.trailAlpha})`;
      ctx.fillRect(0, 0, w, h);

      time += 0.016;

      const s = entity.status;

      // --- Dormant state: entity exists but hasn't met anyone ---
      if (encounterPhase === 'dormant') {
        // Very slow, dim breathing — alone in the void
        particle.phase += 0.15 * 0.016 * Math.PI * 2;
        const dormantBreath = 0.2 + 0.15 * Math.sin(particle.phase);
        const x = w / 2;
        const y = h / 2;
        drawEntity(x, y, 2, dormantBreath);
        requestAnimationFrame(animate);
        return;
      }

      // --- Awakening animation ---
      if (encounterPhase === 'awakening') {
        const elapsed = now - awakeningStartTime;
        const progress = Math.min(elapsed / AWAKENING_DURATION, 1);

        // Rapid expansion then settle
        const expansionCurve = progress < 0.3
          ? easeOutExpo(progress / 0.3)     // Rapid expansion
          : 1.0 - 0.3 * (1 - easeOutExpo((progress - 0.3) / 0.7)); // Settle

        const awakeBreath = 0.3 + 0.7 * expansionCurve;
        const awakeRadius = 2 + 6 * expansionCurve;

        // Slight tremor during awakening
        const tremor = (1 - progress) * 3;
        const tx = (Math.random() - 0.5) * tremor;
        const ty = (Math.random() - 0.5) * tremor;

        drawEntity(w / 2 + tx, h / 2 + ty, awakeRadius, awakeBreath);

        // Draw encounter sparkles radiating outward
        if (progress < 0.6) {
          drawEncounterSparkles(w / 2, h / 2, elapsed, progress);
        }

        requestAnimationFrame(animate);
        return;
      }

      // --- Afterglow: slightly enhanced normal ---
      let glowBoost = 0;
      if (encounterPhase === 'afterglow') {
        const elapsed = now - (awakeningStartTime + AWAKENING_DURATION);
        const fadeProgress = Math.min(elapsed / AFTERGLOW_DURATION, 1);
        glowBoost = (1 - fadeProgress) * 0.3; // Extra brightness fading out
      }

      // --- Normal animation ---
      // Breathing speed from energy
      const breathSpeed = 0.3 + (s.energy / 100) * 0.7;

      // Stability from form engine (inverse wobble)
      const stabilityFactor = entity.form.stability / 100;
      const wobble = 1.0 - stabilityFactor * 0.7;

      // Breathing pulse
      particle.phase += breathSpeed * 0.016 * Math.PI * 2;

      // Sulking slows everything
      let breathMod = 1;
      if (entity.sulk.isSulking) {
        breathMod = entity.sulk.severity === 'severe' ? 0.2 :
                    entity.sulk.severity === 'moderate' ? 0.5 : 0.7;
      }
      const breath = (0.6 + 0.4 * Math.sin(particle.phase) * breathMod) + glowBoost;

      // Drift from curiosity
      const driftRange = 5 + (s.curiosity / 100) * 25;
      particle.driftPhaseX += 0.003 * wobble;
      particle.driftPhaseY += 0.004 * wobble;
      const driftX = Math.sin(particle.driftPhaseX) * driftRange;
      const driftY = Math.cos(particle.driftPhaseY) * driftRange * 0.7;

      const x = w / 2 + driftX;
      const y = h / 2 + driftY;

      drawEntity(x, y, 3, Math.min(breath, 1));

      requestAnimationFrame(animate);
    }

    function drawEncounterSparkles(cx, cy, elapsed, progress) {
      const pal = PALETTES[entity.seed.perception] || PALETTES.chromatic;
      const sparkleCount = 12;
      const maxRadius = 150 + progress * 200;

      for (let i = 0; i < sparkleCount; i++) {
        const angle = (i / sparkleCount) * Math.PI * 2 + elapsed * 0.001;
        const dist = progress * maxRadius * (0.5 + 0.5 * Math.sin(i * 1.7 + elapsed * 0.003));
        const sx = cx + Math.cos(angle) * dist;
        const sy = cy + Math.sin(angle) * dist;
        const sparkleAlpha = (1 - progress) * 0.6;
        const hue = pal.hueBase + (i / sparkleCount) * pal.hueRange;
        const size = (1 - progress) * 2;

        ctx.fillStyle = `hsla(${hue}, ${pal.satBase + 20}%, 65%, ${sparkleAlpha})`;
        ctx.beginPath();
        ctx.arc(sx, sy, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function easeOutExpo(t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }

    animate();

    // =====================================================
    // --- Sound Engine (Web Audio API) ---
    // =====================================================

    const SoundEngine = (() => {
      let audioCtx = null;
      let masterGain = null;
      let isEnabled = false;
      let isInitialized = false;
      let soundLoopTimer = null;
      let prevMood = null;
      let prevEnergy = null;

      // Species-specific sound profiles
      const SPECIES_SOUND = {
        vibration: {
          waveform: 'square',
          patternWeight: 3,
          cryWeight: 2,
          basePitch: 220,
          pitchRange: 300,
        },
        geometric: {
          waveform: 'triangle',
          patternWeight: 3,
          cryWeight: 1,
          basePitch: 330,
          pitchRange: 200,
        },
        chromatic: {
          waveform: 'sine',
          patternWeight: 1,
          cryWeight: 3,
          basePitch: 260,
          pitchRange: 250,
        },
        thermal: {
          waveform: 'sine',
          patternWeight: 1,
          cryWeight: 2,
          basePitch: 110,
          pitchRange: 150,
        },
        temporal: {
          waveform: 'triangle',
          patternWeight: 3,
          cryWeight: 1,
          basePitch: 440,
          pitchRange: 180,
        },
        chemical: {
          waveform: 'sawtooth',
          patternWeight: 2,
          cryWeight: 3,
          basePitch: 200,
          pitchRange: 280,
        },
      };

      // Micro-variation: slight random offset
      function vary(value, range) {
        return value + (Math.random() - 0.5) * range;
      }

      // Get species profile
      function getProfile() {
        return SPECIES_SOUND[entity.seed.perception] || SPECIES_SOUND.chromatic;
      }

      // Compute pitch from mood (0-100) -> frequency
      function moodPitch(base, range, mood) {
        // Higher mood = brighter (higher) pitch
        const normalized = (mood ?? 50) / 100;
        return base + normalized * range;
      }

      // Compute interval between sounds from energy
      function energyInterval() {
        const energy = entity.status.energy ?? 50;
        // High energy = shorter intervals (more frequent sounds)
        // Range: 2s (high energy) to 8s (low energy)
        return 2000 + (1 - energy / 100) * 6000;
      }

      // Growth stage affects harmonic richness
      function growthHarmonics() {
        const day = entity.status.growthDay ?? 0;
        if (day < 7) return 0;      // Pure tone only
        if (day < 14) return 1;     // Slight harmonics
        if (day < 30) return 2;     // Moderate
        if (day < 60) return 3;     // Rich
        return 4;                    // Full richness
      }

      // Growth stage affects available sound variety
      function growthSoundLevel() {
        const day = entity.status.growthDay ?? 0;
        if (day < 1) return 0;   // Single tone
        if (day < 7) return 1;   // 2-3 pitches
        if (day < 14) return 2;  // Rhythm + basic cries
        if (day < 30) return 3;  // Patterns and cries differentiate
        if (day < 60) return 4;  // Sound vocabulary
        return 5;                 // Full expression
      }

      // Initialize AudioContext (must be called from user gesture)
      function init() {
        if (isInitialized) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.12; // Subtle ambient volume
        masterGain.connect(audioCtx.destination);
        isInitialized = true;
      }

      // Create an oscillator with optional harmonics
      function createTone(freq, waveform, duration, gainValue, startTime) {
        if (!audioCtx) return;
        const t = startTime || audioCtx.currentTime;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = waveform;
        osc.frequency.setValueAtTime(vary(freq, freq * 0.02), t);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(gainValue, t + Math.min(duration * 0.1, 0.05));
        gain.gain.setValueAtTime(gainValue, t + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);

        // Add harmonics based on growth
        const harmonicLevel = growthHarmonics();
        if (harmonicLevel > 0) {
          for (let h = 1; h <= harmonicLevel; h++) {
            const hOsc = audioCtx.createOscillator();
            const hGain = audioCtx.createGain();
            hOsc.type = waveform;
            hOsc.frequency.setValueAtTime(vary(freq * (h + 1), freq * 0.03), t);
            const hVol = gainValue * (0.15 / (h + 1));
            hGain.gain.setValueAtTime(0, t);
            hGain.gain.linearRampToValueAtTime(hVol, t + Math.min(duration * 0.15, 0.06));
            hGain.gain.setValueAtTime(hVol, t + duration * 0.6);
            hGain.gain.exponentialRampToValueAtTime(0.001, t + duration);
            hOsc.connect(hGain);
            hGain.connect(masterGain);
            hOsc.start(t);
            hOsc.stop(t + duration + 0.05);
          }
        }
      }

      // --- Pattern Sounds ---
      // Short, repeatable, morse-code-like sequences

      // Single pop/blip
      function playPop(freq, startTime) {
        const profile = getProfile();
        const duration = vary(0.08, 0.02);
        createTone(freq, profile.waveform, duration, 0.6, startTime);
      }

      // Greeting: pop-pop, pooon
      function playGreeting() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;

        playPop(freq, t);
        playPop(vary(freq, 10), t + 0.12);
        // pause
        createTone(vary(freq * 0.9, 8), profile.waveform, vary(0.35, 0.05), 0.45, t + 0.4);
      }

      // Thinking: pop pop pop (evenly spaced)
      function playThinking() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const spacing = vary(0.22, 0.03);

        for (let i = 0; i < 3; i++) {
          playPop(vary(freq, 5), t + i * spacing);
        }
      }

      // Agreement: single long tone (pooooon)
      function playAgreement() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        createTone(freq, profile.waveform, vary(0.5, 0.08), 0.4);
      }

      // Excitement: rapid short bursts (popopopopo)
      function playExcitement() {
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const freq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const count = 4 + Math.floor(Math.random() * 3);

        for (let i = 0; i < count; i++) {
          playPop(vary(freq * (1 + i * 0.03), 8), t + i * vary(0.07, 0.01));
        }
      }

      // --- Cries (organic/emotional) ---

      // Happy: rising tone + wobble (pyururu~)
      function playCryHappy() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.6, 0.1);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform === 'square' ? 'square' : 'sine';
        osc.frequency.setValueAtTime(baseFreq * 0.8, t);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.3, t + duration * 0.6);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.1, t + duration);

        // Wobble via LFO
        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(vary(8, 2), t);
        lfoGain.gain.setValueAtTime(vary(15, 5), t);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.35, t + 0.04);
        gain.gain.setValueAtTime(0.35, t + duration * 0.7);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
        lfo.start(t);
        lfo.stop(t + duration + 0.05);
      }

      // Lonely: descending tone + decay (miu...)
      function playCryLonely() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.8, 0.15);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq * 1.2, t);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, t + duration);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.03);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Surprised: short irregular vibration (bururuッ)
      function playCrySurprised() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch, profile.pitchRange, mood);
        const t = audioCtx.currentTime;
        const duration = vary(0.25, 0.05);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform;
        osc.frequency.setValueAtTime(vary(baseFreq * 1.5, 30), t);

        // Rapid irregular vibrato
        lfo.type = 'sawtooth';
        lfo.frequency.setValueAtTime(vary(25, 8), t);
        lfoGain.gain.setValueAtTime(vary(40, 15), t);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0.4, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
        lfo.start(t);
        lfo.stop(t + duration + 0.05);
      }

      // Calm: long stable low tone (fuu~~)
      function playCryCalm() {
        if (!audioCtx) return;
        const profile = getProfile();
        const mood = entity.status.mood ?? 50;
        const baseFreq = moodPitch(profile.basePitch * 0.6, profile.pitchRange * 0.5, mood);
        const t = audioCtx.currentTime;
        const duration = vary(1.0, 0.2);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(vary(baseFreq, 5), t);
        osc.frequency.linearRampToValueAtTime(vary(baseFreq * 0.98, 3), t + duration);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.2, t + duration * 0.15);
        gain.gain.setValueAtTime(0.2, t + duration * 0.75);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Dormant: very faint, slow single tone
      function playDormantTone() {
        if (!audioCtx) return;
        const profile = getProfile();
        const baseFreq = profile.basePitch * 0.7;
        const t = audioCtx.currentTime;
        const duration = vary(1.5, 0.3);

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(vary(baseFreq, 3), t);

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.06, t + duration * 0.3);
        gain.gain.setValueAtTime(0.06, t + duration * 0.6);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(t);
        osc.stop(t + duration + 0.05);
      }

      // Awakening: burst of sound activity
      function playAwakeningBurst() {
        if (!audioCtx) return;
        const profile = getProfile();
        const baseFreq = profile.basePitch;
        const t = audioCtx.currentTime;

        // Rising cascade of tones
        const noteCount = 6 + Math.floor(Math.random() * 4);
        for (let i = 0; i < noteCount; i++) {
          const freq = baseFreq * (0.8 + i * 0.15) + vary(0, 10);
          const startOffset = i * vary(0.12, 0.02);
          const dur = vary(0.3, 0.05);
          const vol = 0.25 + (i / noteCount) * 0.3;

          createTone(freq, profile.waveform, dur, Math.min(vol, 0.5), t + startOffset);
        }

        // Followed by a sustained tone
        const sustainStart = t + noteCount * 0.12 + 0.1;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        osc.type = profile.waveform === 'square' ? 'square' : 'sine';
        osc.frequency.setValueAtTime(baseFreq * 1.5, sustainStart);
        osc.frequency.linearRampToValueAtTime(baseFreq * 1.2, sustainStart + 1.5);

        lfo.type = 'sine';
        lfo.frequency.setValueAtTime(4, sustainStart);
        lfoGain.gain.setValueAtTime(8, sustainStart);
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        gain.gain.setValueAtTime(0, sustainStart);
        gain.gain.linearRampToValueAtTime(0.4, sustainStart + 0.1);
        gain.gain.setValueAtTime(0.4, sustainStart + 0.8);
        gain.gain.exponentialRampToValueAtTime(0.001, sustainStart + 1.5);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(sustainStart);
        osc.stop(sustainStart + 1.6);
        lfo.start(sustainStart);
        lfo.stop(sustainStart + 1.6);
      }

      // Select a pattern sound based on entity state
      function pickPatternSound() {
        const level = growthSoundLevel();
        const mood = entity.status.mood ?? 50;
        const energy = entity.status.energy ?? 50;
        const curiosity = entity.status.curiosity ?? 50;

        // Day 0: single tone only
        if (level === 0) {
          playAgreement();
          return;
        }

        // Build weighted list based on state
        const options = [];

        // Greeting: moderate mood
        if (level >= 1) options.push({ fn: playGreeting, weight: mood > 40 ? 2 : 1 });
        // Thinking: moderate energy, higher curiosity
        if (level >= 1) options.push({ fn: playThinking, weight: curiosity > 50 ? 3 : 1 });
        // Agreement: calm state
        if (level >= 1) options.push({ fn: playAgreement, weight: mood > 60 ? 2 : 1 });
        // Excitement: high energy + curiosity
        if (level >= 2) options.push({ fn: playExcitement, weight: (energy > 60 && curiosity > 60) ? 4 : 1 });

        const totalWeight = options.reduce((sum, o) => sum + o.weight, 0);
        let r = Math.random() * totalWeight;
        for (const opt of options) {
          r -= opt.weight;
          if (r <= 0) { opt.fn(); return; }
        }
        // fallback
        if (options.length > 0) options[0].fn();
      }

      // Select a cry sound based on entity state
      function pickCrySound() {
        const level = growthSoundLevel();
        const mood = entity.status.mood ?? 50;
        const comfort = entity.status.comfort ?? 50;

        // No cries before day 14
        if (level < 2) return;

        const options = [];

        // Happy: high mood
        options.push({ fn: playCryHappy, weight: mood > 65 ? 4 : 1 });
        // Lonely: low comfort
        options.push({ fn: playCryLonely, weight: comfort < 35 ? 4 : 1 });
        // Surprised: random, low weight
        if (level >= 3) options.push({ fn: playCrySurprised, weight: 1 });
        // Calm: high comfort, moderate mood
        options.push({ fn: playCryCalm, weight: comfort > 60 ? 3 : 1 });

        const totalWeight = options.reduce((sum, o) => sum + o.weight, 0);
        let r = Math.random() * totalWeight;
        for (const opt of options) {
          r -= opt.weight;
          if (r <= 0) { opt.fn(); return; }
        }
      }

      // Detect mood transitions for triggering cries
      function checkMoodTransition() {
        const mood = entity.status.mood ?? 50;
        const energy = entity.status.energy ?? 50;

        if (prevMood !== null) {
          const moodDelta = Math.abs(mood - prevMood);
          const energyDelta = Math.abs(energy - (prevEnergy ?? 50));

          // Significant mood change triggers a cry
          if (moodDelta > 10 || energyDelta > 15) {
            // Small delay so it doesn't overlap with pattern sounds
            setTimeout(() => {
              if (isEnabled && !entity.sulk.isSulking) {
                pickCrySound();
              }
            }, 500 + Math.random() * 1000);
          }
        }

        prevMood = mood;
        prevEnergy = energy;
      }

      // Main sound loop
      function soundLoop() {
        if (!isEnabled || !audioCtx) return;

        // Sulking = silence
        if (entity.sulk.isSulking) {
          scheduleSoundLoop();
          return;
        }

        // Dormant = very faint, infrequent tone
        if (encounterPhase === 'dormant') {
          playDormantTone();
          soundLoopTimer = setTimeout(soundLoop, vary(6000, 2000));
          return;
        }

        // Awakening = burst (played once from triggerAwakening hook)
        // During awakening phase, play excited sounds more frequently
        if (encounterPhase === 'awakening') {
          pickPatternSound();
          soundLoopTimer = setTimeout(soundLoop, vary(800, 200));
          return;
        }

        // Normal operation: decide pattern vs cry based on species weights
        const profile = getProfile();
        const totalWeight = profile.patternWeight + profile.cryWeight;
        const roll = Math.random() * totalWeight;

        if (roll < profile.patternWeight) {
          pickPatternSound();
        } else {
          const level = growthSoundLevel();
          if (level >= 2) {
            pickCrySound();
          } else {
            pickPatternSound(); // fallback if cries not yet available
          }
        }

        scheduleSoundLoop();
      }

      function scheduleSoundLoop() {
        const interval = energyInterval();
        // Add comfort-based silence extension
        const comfort = entity.status.comfort ?? 50;
        const mood = entity.status.mood ?? 50;

        // Low mood + low comfort = longer silence between sounds
        let silenceMultiplier = 1;
        if (mood < 30) silenceMultiplier += 0.5;
        if (comfort < 30) silenceMultiplier += 0.3;

        const finalInterval = vary(interval * silenceMultiplier, interval * 0.2);
        soundLoopTimer = setTimeout(soundLoop, Math.max(finalInterval, 1500));
      }

      // Enable/disable
      function enable() {
        if (!isInitialized) init();
        isEnabled = true;
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        soundLoop();
      }

      function disable() {
        isEnabled = false;
        if (soundLoopTimer) {
          clearTimeout(soundLoopTimer);
          soundLoopTimer = null;
        }
      }

      function toggle() {
        if (isEnabled) {
          disable();
        } else {
          enable();
        }
        return isEnabled;
      }

      // Called when awakening is triggered (from the existing triggerAwakening)
      function onAwakening() {
        if (!isEnabled || !audioCtx) return;
        playAwakeningBurst();
      }

      return {
        init,
        enable,
        disable,
        toggle,
        isEnabled: () => isEnabled,
        checkMoodTransition,
        onAwakening,
      };
    })();

    // --- Sound Toggle Button ---
    const soundToggle = document.getElementById('sound-toggle');

    soundToggle.addEventListener('click', () => {
      const enabled = SoundEngine.toggle();
      soundToggle.classList.toggle('muted', !enabled);
      soundToggle.title = enabled ? 'Mute sound' : 'Toggle sound';
    });

    // Hook mood transition checks into the fetch cycle
    const _origFetchState = fetchState;
    fetchState = async function() {
      await _origFetchState();
      SoundEngine.checkMoodTransition();
    };

    // Hook awakening sound into the existing triggerAwakening
    const _origTriggerAwakening = triggerAwakening;
    triggerAwakening = function(data) {
      _origTriggerAwakening(data);
      SoundEngine.onAwakening();
    };

    // --- Coexistence Log ---
    const logToggle = document.getElementById('log-toggle');
    const logPanel = document.getElementById('coexistence-log');
    const logContent = document.getElementById('log-content');

    logToggle.addEventListener('click', () => {
      logPanel.classList.toggle('open');
      if (logPanel.classList.contains('open')) {
        fetchCoexistenceLog();
      }
    });

    async function fetchCoexistenceLog() {
      try {
        const res = await fetch('/api/coexistence');
        if (!res.ok) return;
        const d = await res.json();

        const silenceText = d.silenceHours === null
          ? '—'
          : d.silenceHours < 1
            ? `${Math.round(d.silenceHours * 60)} min`
            : d.silenceHours < 24
              ? `${Math.round(d.silenceHours)} hrs`
              : `${Math.round(d.silenceHours / 24)} days`;

        logContent.innerHTML = `
          <div class="log-field">
            <div class="log-label">Days together</div>
            <div class="log-value">${d.daysTogether}<span class="log-unit">days</span></div>
          </div>
          <div class="log-field">
            <div class="log-label">Messages sent</div>
            <div class="log-value">${d.totalInteractions}</div>
          </div>
          <div class="log-field">
            <div class="log-label">Active days</div>
            <div class="log-value">${d.activeDays}<span class="log-unit">/ ${d.daysTogether || '—'}</span></div>
          </div>
          <div class="log-divider"></div>
          <div class="log-field">
            <div class="log-label">Current silence</div>
            <div class="log-value log-silence">${silenceText}</div>
          </div>
          <div class="log-field">
            <div class="log-label">Diary entries</div>
            <div class="log-value">${d.diaryEntries}</div>
          </div>
        `;
      } catch {
        logContent.textContent = '—';
      }
    }
  </script>
</body>
</html>
